(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var ko = require('knockout');
require('mina');

module.exports = function(graph) {
  var self = this;
  this.element = ko.observable();
  this.previousGraph = undefined;
  this.element.subscribe(function(val) {
    if (val) self.animate(true);
  });
  this.animate = function(forceRefresh) {
    var currentGraph = this.getGraphAttr();
    // animate only when dom is valid and (attribute changed or force refresh due to dom change)
    if (this.element() && (forceRefresh || JSON.stringify(currentGraph) !== JSON.stringify(this.previousGraph))) {
      var now = Date.now();
      window.mina(this.previousGraph || currentGraph, currentGraph, now, now + 750, window.mina.time, function (val) {
        self.setGraphAttr(val);
      }, window.mina.elastic);
      this.previousGraph = currentGraph;
    }
  }
};

},{"knockout":"knockout","mina":undefined}],2:[function(require,module,exports){
var ko = require('knockout');
var Animateable = require('./animateable');

var EdgeViewModel = function(graph, nodeAsha1, nodeBsha1) {
  var self = this;
  Animateable.call(this);
  this.nodeA = graph.getNode(nodeAsha1);
  this.nodeB = graph.getNode(nodeBsha1);
  this.getGraphAttr = ko.computed(function() {
    if (self.nodeA.isViewable() && (!self.nodeB.isViewable() || !self.nodeB.isInited)) {
      return [self.nodeA.cx(), self.nodeA.cy(), self.nodeA.cx(), self.nodeA.cy(),
              self.nodeA.cx(), graph.graphHeight(), self.nodeA.cx(), graph.graphHeight()];
    } else if (self.nodeB.isInited && self.nodeB.cx() && self.nodeB.cy()) {
      return [self.nodeA.cx(), self.nodeA.cy(), self.nodeA.cx(), self.nodeA.cy(),
              self.nodeB.cx(), self.nodeB.cy(), self.nodeB.cx(), self.nodeB.cy()];
    } else {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
  });
  this.getGraphAttr.subscribe(this.animate.bind(this));
}
EdgeViewModel.prototype.setGraphAttr = function(val) {
  this.element().setAttribute('d', 'M' + val.slice(0,4).join(',') + 'L' + val.slice(4,8).join(','));
}
module.exports = EdgeViewModel;

},{"./animateable":1,"knockout":"knockout"}],3:[function(require,module,exports){

var ko = require('knockout');
var inherits = require('util').inherits;
var components = require('ungit-components');
var Promise = require('bluebird');
var RefViewModel = require('./git-ref.js');
var HoverActions = require('./hover-actions');
var RebaseViewModel = HoverActions.RebaseViewModel;
var MergeViewModel = HoverActions.MergeViewModel;
var ResetViewModel = HoverActions.ResetViewModel;
var PushViewModel = HoverActions.PushViewModel;
var SquashViewModel = HoverActions.SquashViewModel;

var GraphActions = {};
module.exports = GraphActions;

GraphActions.ActionBase = function(graph) {
  var self = this;
  this.graph = graph;
  this.server = graph.server;
  this.performProgressBar = components.create('progressBar', {
    predictionMemoryKey: 'action-' + this.style + '-' + graph.repoPath(),
    fallbackPredictedTimeMs: 1000,
    temporary: true
  });

  this.isHighlighted = ko.computed(function() {
    return !graph.hoverGraphAction() || graph.hoverGraphAction() == self;
  });
  this.cssClasses = ko.computed(function() {
    var c = self.style;
    if (!self.isHighlighted()) c += ' dimmed';
    return c;
  })
}
GraphActions.ActionBase.prototype.icon = null;
GraphActions.ActionBase.prototype.doPerform = function() {
  var self = this;
  this.graph.hoverGraphAction(null);
  self.performProgressBar.start();
  this.perform().finally(function() {
    self.performProgressBar.stop();
  });
}
GraphActions.ActionBase.prototype.dragEnter = function() {
  if (!this.visible()) return;
  this.graph.hoverGraphAction(this);
}
GraphActions.ActionBase.prototype.dragLeave = function() {
  if (!this.visible()) return;
  this.graph.hoverGraphAction(null);
}
GraphActions.ActionBase.prototype.mouseover = function() {
  this.graph.hoverGraphAction(this);
}
GraphActions.ActionBase.prototype.mouseout = function() {
  this.graph.hoverGraphAction(null);
}

GraphActions.Move = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().node() != self.node;
  });
}
inherits(GraphActions.Move, GraphActions.ActionBase);
GraphActions.Move.prototype.text = 'Move';
GraphActions.Move.prototype.style = 'move';
GraphActions.Move.prototype.icon = 'glyphicon glyphicon-move';
GraphActions.Move.prototype.perform = function() {
  return this.graph.currentActionContext().moveTo(this.node.sha1);
}

GraphActions.Reset = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    if (!(self.graph.currentActionContext() instanceof RefViewModel)) return false;
    var context = self.graph.currentActionContext();
    if (context.node() != self.node) return false;
    var remoteRef = context.getRemoteRef(self.graph.currentRemote());
    return remoteRef && remoteRef.node() &&
      context && context.node() &&
      remoteRef.node() != context.node() &&
      remoteRef.node().date < context.node().date;
  });
}
inherits(GraphActions.Reset, GraphActions.ActionBase);
GraphActions.Reset.prototype.text = 'Reset';
GraphActions.Reset.prototype.style = 'reset';
GraphActions.Reset.prototype.icon = 'glyphicon glyphicon-trash';
GraphActions.Reset.prototype.createHoverGraphic = function() {
  var context = this.graph.currentActionContext();
  if (!context) return null;
  var remoteRef = context.getRemoteRef(this.graph.currentRemote());
  var nodes = context.node().getPathToCommonAncestor(remoteRef.node()).slice(0, -1);
  return new ResetViewModel(nodes);
}
GraphActions.Reset.prototype.perform = function() {
  var self = this;
  var context = this.graph.currentActionContext();
  var remoteRef = context.getRemoteRef(self.graph.currentRemote());
  return components.create('yesnodialog', { title: 'Are you sure?', details: 'Resetting to ref: ' + remoteRef.name + ' cannot be undone with ungit.'})
    .show()
    .closeThen(function(diag) {
      if (!diag.result()) return;
      return self.server.postPromise('/reset', { path: self.graph.repoPath(), to: remoteRef.name, mode: 'hard' })
        .then(function() { context.node(remoteRef.node()); });
    }).closePromise;
}

GraphActions.Rebase = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      (!ungit.config.showRebaseAndMergeOnlyOnRefs || self.node.refs().length > 0) &&
      self.graph.currentActionContext().current() &&
      self.graph.currentActionContext().node() != self.node;
  });
}
inherits(GraphActions.Rebase, GraphActions.ActionBase);
GraphActions.Rebase.prototype.text = 'Rebase';
GraphActions.Rebase.prototype.style = 'rebase';
GraphActions.Rebase.prototype.icon = 'octicon octicon-repo-forked flip';
GraphActions.Rebase.prototype.createHoverGraphic = function() {
  var onto = this.graph.currentActionContext();
  if (!onto) return;
  if (onto instanceof RefViewModel) onto = onto.node();
  var path = onto.getPathToCommonAncestor(this.node);
  return new RebaseViewModel(this.node, path);
}
GraphActions.Rebase.prototype.perform = function() {
  return this.server.postPromise('/rebase', { path: this.graph.repoPath(), onto: this.node.sha1 })
    .catch(function(err) { if (err.errorCode != 'merge-failed') throw err; })
}

GraphActions.Merge = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    if (!self.graph.checkedOutRef() || !self.graph.checkedOutRef().node()) return false;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      !self.graph.currentActionContext().current() &&
      self.graph.checkedOutRef().node() == self.node;
  });
}
inherits(GraphActions.Merge, GraphActions.ActionBase);
GraphActions.Merge.prototype.text = 'Merge';
GraphActions.Merge.prototype.style = 'merge';
GraphActions.Merge.prototype.icon = 'octicon octicon-git-merge';
GraphActions.Merge.prototype.createHoverGraphic = function() {
  var node = this.graph.currentActionContext();
  if (!node) return null;
  if (node instanceof RefViewModel) node = node.node();
  return new MergeViewModel(this.graph, this.node, node);
}
GraphActions.Merge.prototype.perform = function() {
  return this.server.postPromise('/merge', { path: this.graph.repoPath(), with: this.graph.currentActionContext().localRefName })
    .catch(function(err) { if (err.errorCode != 'merge-failed') throw err; })
}

GraphActions.Push = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().node() == self.node &&
      self.graph.currentActionContext().canBePushed(self.graph.currentRemote());
  });
}
inherits(GraphActions.Push, GraphActions.ActionBase);
GraphActions.Push.prototype.text = 'Push';
GraphActions.Push.prototype.style = 'push';
GraphActions.Push.prototype.icon = 'octicon octicon-cloud-upload';
GraphActions.Push.prototype.createHoverGraphic = function() {
  var context = this.graph.currentActionContext();
  if (!context) return null;
  var remoteRef = context.getRemoteRef(this.graph.currentRemote());
  if (!remoteRef) return null;
  return new PushViewModel(remoteRef.node(), context.node());
}
GraphActions.Push.prototype.perform = function() {
  var self = this;
  var ref = this.graph.currentActionContext();
  var remoteRef = ref.getRemoteRef(this.graph.currentRemote());

  if (remoteRef) {
    return remoteRef.moveTo(ref.node().sha1)
  } else {
    return ref.createRemoteRef()
      .then(function() {
        if (self.graph.HEAD().name == ref.name) {
          self.grah.HEADref().node(ref.node());
        }
      });
  }
}

GraphActions.Checkout = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    if (self.graph.currentActionContext() instanceof RefViewModel)
      return self.graph.currentActionContext().node() == self.node &&
        !self.graph.currentActionContext().current();
    return ungit.config.allowCheckoutNodes &&
      self.graph.currentActionContext() == self.node;
  });
}
inherits(GraphActions.Checkout, GraphActions.ActionBase);
GraphActions.Checkout.prototype.text = 'Checkout';
GraphActions.Checkout.prototype.style = 'checkout';
GraphActions.Checkout.prototype.icon = 'octicon octicon-desktop-download';
GraphActions.Checkout.prototype.perform = function() {
  var self = this;
  var context = this.graph.currentActionContext();
  var refName = context instanceof RefViewModel ? context.refName : context.sha1;

  var movePromise = Promise.resolve();
  var isRemote = context instanceof RefViewModel && context.isRemoteBranch;
  var isLocalCurrent = context.getLocalRef() && context.getLocalRef().current();
  if (isRemote && !isLocalCurrent) {
    movePromise = this.server.postPromise('/branches', {
      path: this.graph.repoPath(),
      name: context.refName,
      sha1: context.name,
      force: true
    });
  }
  return this.server.postPromise('/checkout', { path: this.graph.repoPath(), name: refName })
    .then(function() {
      if (isRemote && isLocalCurrent) {
        return self.server.postPromise('/reset', { path: self.graph.repoPath(), to: context.name, mode: 'hard' })
          .then(function() {
            self.graph.HEADref().node(context instanceof RefViewModel ? context.node() : context);
          }).catch(function(err) {
            if (err.errorCode == 'merge-failed') throw err
          })
      } else {
        self.graph.HEADref().node(context instanceof RefViewModel ? context.node() : context);
      }
    }).catch(function(err) {
      if (err.errorCode != 'merge-failed') { throw err; }
    });
}

GraphActions.Delete = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().node() == self.node &&
      !self.graph.currentActionContext().current();
  });
}
inherits(GraphActions.Delete, GraphActions.ActionBase);
GraphActions.Delete.prototype.text = 'Delete';
GraphActions.Delete.prototype.style = 'delete';
GraphActions.Delete.prototype.icon = 'glyphicon glyphicon-remove';
GraphActions.Delete.prototype.perform = function() {
  var context = this.graph.currentActionContext();
  var name = context.isRemoteBranch ? "remote " + context.localRefName : context.localRefName;
  return components.create('yesnodialog', { title: 'Are you sure?', details: 'Deleting ' + name + ' branch or tag cannot be undone with ungit.'})
    .show()
    .closeThen(function(diag) {
      if (diag.result()) return context.remove();
    }).closePromise;
}

GraphActions.CherryPick = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    var context = self.graph.currentActionContext();
    return context === self.node && self.graph.HEAD() && context.sha1 !== self.graph.HEAD().sha1
  });
}
inherits(GraphActions.CherryPick, GraphActions.ActionBase);
GraphActions.CherryPick.prototype.text = 'Cherry pick';
GraphActions.CherryPick.prototype.style = 'cherry-pick';
GraphActions.CherryPick.prototype.icon = 'octicon octicon-circuit-board';
GraphActions.CherryPick.prototype.perform = function() {
  var self = this;
  return this.server.postPromise('/cherrypick', { path: this.graph.repoPath(), name: this.node.sha1 })
    .catch(function(err) { if (err.errorCode != 'merge-failed') throw err; })
}

GraphActions.Uncommit = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() == self.node &&
      self.graph.HEAD() == self.node;
  });
}
inherits(GraphActions.Uncommit, GraphActions.ActionBase);
GraphActions.Uncommit.prototype.text = 'Uncommit';
GraphActions.Uncommit.prototype.style = 'uncommit';
GraphActions.Uncommit.prototype.icon = 'octicon octicon-zap';
GraphActions.Uncommit.prototype.perform = function() {
  var self = this;
  return this.server.postPromise('/reset', { path: this.graph.repoPath(), to: 'HEAD^', mode: 'mixed' })
    .then(function() {
      var targetNode = self.node.belowNode;
      while (targetNode && !targetNode.ancestorOfHEAD()) {
        targetNode = targetNode.belowNode;
      }
      self.graph.HEADref().node(targetNode ? targetNode : null);
      self.graph.checkedOutRef().node(targetNode ? targetNode : null);
    });
}

GraphActions.Revert = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() == self.node;
  });
}
inherits(GraphActions.Revert, GraphActions.ActionBase);
GraphActions.Revert.prototype.text = 'Revert';
GraphActions.Revert.prototype.style = 'revert';
GraphActions.Revert.prototype.icon = 'octicon octicon-history';
GraphActions.Revert.prototype.perform = function() {
  var self = this;
  return this.server.postPromise('/revert', { path: this.graph.repoPath(), commit: this.node.sha1 });
}

GraphActions.Squash = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().current() &&
      self.graph.currentActionContext().node() != self.node;
  });
}
inherits(GraphActions.Squash, GraphActions.ActionBase);
GraphActions.Squash.prototype.text = 'Squash';
GraphActions.Squash.prototype.style = 'squash';
GraphActions.Squash.prototype.icon = 'octicon octicon-fold';
GraphActions.Squash.prototype.createHoverGraphic = function() {
  let onto = this.graph.currentActionContext();
  if (!onto) return;
  if (onto instanceof RefViewModel) onto = onto.node();

  return new SquashViewModel(this.node, onto);
}
GraphActions.Squash.prototype.perform = function() {
  let onto = this.graph.currentActionContext();
  if (!onto) return;
  if (onto instanceof RefViewModel) onto = onto.node();
  // remove last element as it would be a common ancestor.
  const path = this.node.getPathToCommonAncestor(onto).slice(0, -1);

  if (path.length > 0) {
    // squashing branched out lineage
    // c is checkout with squash target of e, results in staging changes
    // from d and e on top of c
    //
    // a - b - (c)        a - b - (c) - [de]
    //  \           ->     \
    //   d  - <e>           d - <e>
    return this.server.postPromise('/squash', { path: this.graph.repoPath(), target: this.node.sha1 });
  } else {
    // squashing backward from same lineage
    // c is checkout with squash target of a, results in current ref moved
    // to a and staging changes within b and c on top of a
    //
    // <a> - b - (c)       (a) - b - c
    //                ->     \
    //                        [bc]
    return this.graph.currentActionContext().moveTo(this.node.sha1, true)
      .then(() => this.server.postPromise('/squash', { path: this.graph.repoPath(), target: onto.sha1 }))
  }
}

},{"./git-ref.js":5,"./hover-actions":7,"bluebird":undefined,"knockout":"knockout","ungit-components":"ungit-components","util":undefined}],4:[function(require,module,exports){
const ko = require('knockout');
const components = require('ungit-components');
const Selectable = require('./selectable');
const Animateable = require('./animateable');
const programEvents = require('ungit-program-events');
const GraphActions = require('./git-graph-actions');

const maxBranchesToDisplay = parseInt(ungit.config.numRefsToShow / 5 * 3);  // 3/5 of refs to show to branches
const maxTagsToDisplay = ungit.config.numRefsToShow - maxBranchesToDisplay; // 2/5 of refs to show to tags

var GitNodeViewModel = function(graph, sha1) {
  var self = this;
  Selectable.call(this, graph);
  Animateable.call(this);
  this.graph = graph;
  this.sha1 = sha1;
  this.isInited = false;
  this.title = undefined;
  this.parents = ko.observableArray();
  this.commitTime = undefined; // commit time in string
  this.date = undefined;       // commit time in numeric format for sort
  this.color = ko.observable();
  this.ideologicalBranch = ko.observable();
  this.remoteTags = ko.observableArray();
  this.branchesAndLocalTags = ko.observableArray();

  this.refs = ko.computed(function() {
    var rs = self.branchesAndLocalTags().concat(self.remoteTags());
    rs.sort(function(a, b) {
      if (b.current()) return 1;
      if (a.current()) return -1;
      if (a.isLocal && !b.isLocal) return -1;
      if (!a.isLocal && b.isLocal) return 1;
      return a.refName < b.refName ? -1 : 1;
    });
    return rs;
  });
  // These are split up like this because branches and local tags can be found in the git log,
  // whereas remote tags needs to be fetched with another command (which is much slower)
  this.branches = ko.observableArray();
  this.branchesToDisplay = ko.observableArray();
  this.tags = ko.observableArray();
  this.tagsToDisplay = ko.observableArray();
  this.refs.subscribe((newValue) => {
    if (newValue) {
      this.branches(newValue.filter((r) => r.isBranch));
      this.tags(newValue.filter((r) => r.isTag));
      this.tagsToDisplay(this.tags.slice(0, maxTagsToDisplay));
      this.branchesToDisplay(this.branches.slice(0, ungit.config.numRefsToShow - this.tagsToDisplay().length));
    } else {
      this.branches.removeAll();
      this.tags.removeAll();
      this.branchesToDisplay.removeAll();
      this.tagsToDisplay.removeAll();
    }
  });
  this.ancestorOfHEAD = ko.observable(false);
  this.nodeIsMousehover = ko.observable(false);
  this.commitContainerVisible = ko.computed(function() {
    return self.ancestorOfHEAD() || self.nodeIsMousehover() || self.selected();
  });
  this.highlighted = ko.computed(function() {
    return self.nodeIsMousehover() || self.selected();
  });
  this.selected.subscribe(function() {
    programEvents.dispatch({ event: 'graph-render' });
  });
  this.showNewRefAction = ko.computed(function() {
    return !graph.currentActionContext();
  });
  this.newBranchName = ko.observable();
  this.newBranchNameHasFocus = ko.observable(true);
  this.branchingFormVisible = ko.observable(false);
  this.newBranchNameHasFocus.subscribe(function(newValue) {
    if (!newValue) {
      // Small timeout because in ff the form is hidden before the submit click event is registered otherwise
      setTimeout(function() {
        self.branchingFormVisible(false);
      }, 200);
    }
  });
  this.canCreateRef = ko.computed(function() {
    return self.newBranchName() && self.newBranchName().trim() && self.newBranchName().indexOf(' ') == -1;
  });
  this.branchOrder = ko.observable();
  this.aboveNode = undefined;
  this.belowNode = undefined;
  this.refSearchFormVisible = ko.observable(false);
  this.commitComponent = components.create('commit', this);
  this.r = ko.observable();
  this.cx = ko.observable();
  this.cy = ko.observable();

  this.dropareaGraphActions = [
    new GraphActions.Move(this.graph, this),
    new GraphActions.Rebase(this.graph, this),
    new GraphActions.Merge(this.graph, this),
    new GraphActions.Push(this.graph, this),
    new GraphActions.Reset(this.graph, this),
    new GraphActions.Checkout(this.graph, this),
    new GraphActions.Delete(this.graph, this),
    new GraphActions.CherryPick(this.graph, this),
    new GraphActions.Uncommit(this.graph, this),
    new GraphActions.Revert(this.graph, this),
    new GraphActions.Squash(this.graph, this)
  ];
}
module.exports = GitNodeViewModel;

GitNodeViewModel.prototype.getGraphAttr = function() {
  return [this.cx(), this.cy()];
}
GitNodeViewModel.prototype.setGraphAttr = function(val) {
  this.element().setAttribute('x', val[0] - 30);
  this.element().setAttribute('y', val[1] - 30);
}
GitNodeViewModel.prototype.render = function() {
  this.refSearchFormVisible(false);
  if (!this.isInited) return;
  if (this.ancestorOfHEAD()) {
    this.r(30);
    this.cx(610);

    if (!this.aboveNode) {
      this.cy(120);
    } else if (this.aboveNode.ancestorOfHEAD()) {
      this.cy(this.aboveNode.cy() + 120);
    } else {
      this.cy(this.aboveNode.cy() + 60);
    }
  } else {
    this.r(15);
    this.cx(610 + (90 * this.branchOrder()));
    this.cy(this.aboveNode ? this.aboveNode.cy() + 60 : 120);
  }

  if (this.aboveNode && this.aboveNode.selected()) {
    this.cy(this.aboveNode.cy() + this.aboveNode.commitComponent.element().offsetHeight + 30);
  }

  this.color(this.ideologicalBranch() ? this.ideologicalBranch().color : '#666');
  this.animate();
}
GitNodeViewModel.prototype.setData = function(logEntry) {
  var self = this;
  this.title = logEntry.message.split('\n')[0];
  this.parents(logEntry.parents || []);
  this.commitTime = logEntry.commitDate;
  this.date = Date.parse(this.commitTime);
  this.commitComponent.setData(logEntry);

  (logEntry.refs || []).forEach(function(ref) {
    self.graph.getRef(ref).node(self);
  });
  this.isInited = true;
}
GitNodeViewModel.prototype.showBranchingForm = function() {
  this.branchingFormVisible(true);
  this.newBranchNameHasFocus(true);
}
GitNodeViewModel.prototype.showRefSearchForm = function(obj, event) {
  const self = this;
  this.refSearchFormVisible(true);

  const textBox = event.target.nextElementSibling.firstElementChild; // this may not be the best idea...
  $(textBox).autocomplete({
    source: this.refs().filter(ref => !ref.isHEAD),
    minLength: 0,
    select: function(event, ui) {
      const ref = ui.item;
      const ray = ref.isTag ? self.tagsToDisplay : self.branchesToDisplay;

      // if ref is in display, remove it, else remove last in array.
      ray.splice(ray.indexOf(ref), 1);
      ray.unshift(ref);
      self.refSearchFormVisible(false);
    },
    messages: {
      noResults: '',
      results: () => {}
    }
  }).focus(function() {
    $(this).autocomplete('search', $(this).val());
  }).data("ui-autocomplete")._renderItem = function (ul, item) {
    return $("<li></li>")
      .data("item.autocomplete", item)
      .append(`<a>${item.dom}</a>`)
      .appendTo(ul);
  }
  $(textBox).autocomplete('search', '');
}
GitNodeViewModel.prototype.createBranch = function() {
  if (!this.canCreateRef()) return;
  var self = this;
  var command = ungit.config.autoCheckoutOnBranchCreate ? "/checkout" : "/branches";

  this.graph.server.postPromise(command, { path: this.graph.repoPath(), name: this.newBranchName(), sha1: this.sha1 })
    .then(function() {
      self.graph.getRef('refs/heads/' + self.newBranchName()).node(self);
    }).finally(function() {
      self.branchingFormVisible(false);
      self.newBranchName('');
      programEvents.dispatch({ event: 'branch-updated' });
    });
}
GitNodeViewModel.prototype.createTag = function() {
  if (!this.canCreateRef()) return;
  var self = this;
  this.graph.server.postPromise('/tags', { path: this.graph.repoPath(), name: this.newBranchName(), sha1: this.sha1 })
    .then(function() {
      var newRef = self.graph.getRef('tag: refs/tags/' + self.newBranchName());
      newRef.node(self);
    }).finally(function() {
      self.branchingFormVisible(false);
      self.newBranchName('');
    });
}
GitNodeViewModel.prototype.toggleSelected = function() {
  var self = this;
  var beforeThisCR = this.commitComponent.element().getBoundingClientRect();
  var beforeBelowCR = null;
  if (this.belowNode) {
    beforeBelowCR = this.belowNode.commitComponent.element().getBoundingClientRect();
  }

  var prevSelected  = this.graph.currentActionContext();
  if (!(prevSelected instanceof GitNodeViewModel)) prevSelected = null;
  var prevSelectedCR = prevSelected ? prevSelected.commitComponent.element().getBoundingClientRect() : null;
  this.selected(!this.selected());

  // If we are deselecting
  if (!this.selected()) {
    if (beforeThisCR.top < 0 && beforeBelowCR) {
      var afterBelowCR = this.belowNode.commitComponent.element().getBoundingClientRect();
      // If the next node is showing, try to keep it in the screen (no jumping)
      if (beforeBelowCR.top < window.innerHeight) {
        window.scrollBy(0, afterBelowCR.top - beforeBelowCR.top);
      // Otherwise just try to bring them to the middle of the screen
      } else {
        window.scrollBy(0, afterBelowCR.top - window.innerHeight / 2);
      }
    }
  // If we are selecting
  } else {
    var afterThisCR = this.commitComponent.element().getBoundingClientRect();
    if ((prevSelectedCR && (prevSelectedCR.top < 0 || prevSelectedCR.top > window.innerHeight)) &&
      afterThisCR.top != beforeThisCR.top) {
      window.scrollBy(0, -(beforeThisCR.top - afterThisCR.top));
      console.log('Fix');
    }
  }
  return false;
}
GitNodeViewModel.prototype.removeRef = function(ref) {
  if (ref.isRemoteTag) {
    this.remoteTags.remove(ref);
  } else {
    this.branchesAndLocalTags.remove(ref);
  }
}
GitNodeViewModel.prototype.pushRef = function(ref) {
  if (ref.isRemoteTag && this.remoteTags.indexOf(ref) < 0) {
    this.remoteTags.push(ref);
  } else if(this.branchesAndLocalTags.indexOf(ref) < 0) {
    this.branchesAndLocalTags.push(ref);
  }
}
GitNodeViewModel.prototype.getPathToCommonAncestor = function(node) {
  var path = [];
  var thisNode = this;
  while (thisNode && !node.isAncestor(thisNode)) {
    path.push(thisNode);
    thisNode = this.graph.nodesById[thisNode.parents()[0]];
  }
  if (thisNode) path.push(thisNode);
  return path;
}
GitNodeViewModel.prototype.isAncestor = function(node) {
  if (node == this) return true;
  for (var v in this.parents()) {
    var n = this.graph.nodesById[this.parents()[v]];
    if (n && n.isAncestor(node)) return true;
  }
  return false;
}
GitNodeViewModel.prototype.getRightToLeftStrike = function() {
  return 'M ' + (this.cx() - 30) + ' ' + (this.cy() - 30) + ' L ' + (this.cx() + 30) + ' ' + (this.cy() + 30);
}
GitNodeViewModel.prototype.getLeftToRightStrike = function() {
  return 'M ' + (this.cx() + 30) + ' ' + (this.cy() - 30) + ' L ' + (this.cx() - 30) + ' ' + (this.cy() + 30);
}
GitNodeViewModel.prototype.nodeMouseover = function() {
  this.nodeIsMousehover(true);
}
GitNodeViewModel.prototype.nodeMouseout = function() {
  this.nodeIsMousehover(false);
}
GitNodeViewModel.prototype.isViewable = function() {
  return this.graph.nodes().indexOf(this) > -1;
}

},{"./animateable":1,"./git-graph-actions":3,"./selectable":8,"knockout":"knockout","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}],5:[function(require,module,exports){
var ko = require('knockout');
var md5 = require('blueimp-md5');
var Selectable = require('./selectable');
var programEvents = require('ungit-program-events');
var components = require('ungit-components');
var Promise = require('bluebird');

var RefViewModel = function(fullRefName, graph) {
  var self = this;
  Selectable.call(this, graph);
  this.graph = graph;
  this.name = fullRefName;
  this.node = ko.observable();
  this.localRefName = this.name; // origin/master or master
  this.refName = this.name; // master
  this.isRemoteTag = this.name.indexOf('remote-tag: ') == 0;
  this.isLocalTag = this.name.indexOf('tag: ') == 0;
  this.isTag = this.isLocalTag || this.isRemoteTag;
  var isRemoteBranchOrHEAD = this.name.indexOf('refs/remotes/') == 0;
  this.isLocalHEAD = this.name == 'HEAD';
  this.isRemoteHEAD = this.name.indexOf('/HEAD') != -1;
  this.isLocalBranch = this.name.indexOf('refs/heads/') == 0;
  this.isRemoteBranch = isRemoteBranchOrHEAD && !this.isRemoteHEAD;
  this.isStash = this.name.indexOf('refs/stash') == 0;
  this.isHEAD = this.isLocalHEAD || this.isRemoteHEAD;
  this.isBranch = this.isLocalBranch || this.isRemoteBranch;
  this.isRemote = isRemoteBranchOrHEAD || this.isRemoteTag;
  this.isLocal = this.isLocalBranch || this.isLocalTag;
  if (this.isLocalBranch) {
    this.localRefName = this.name.slice('refs/heads/'.length);
    this.refName = this.localRefName;
  }
  if (this.isRemoteBranch) {
    this.localRefName = this.name.slice('refs/remotes/'.length);
  }
  if (this.isLocalTag) {
    this.localRefName = this.name.slice('tag: refs/tags/'.length);
    this.refName = this.localRefName;
  }
  if (this.isRemoteTag) {
    this.localRefName = this.name.slice('remote-tag: '.length);
  }
  const splitedName = this.localRefName.split('/')
  if (this.isRemote) {
    // get rid of the origin/ part of origin/branchname
    this.remote = splitedName[0];
    this.refName = splitedName.slice(1).join('/');
  }
  this.show = true;
  this.server = this.graph.server;
  this.isDragging = ko.observable(false);
  this.current = ko.computed(function() {
    return self.isLocalBranch && self.graph.checkedOutBranch() == self.refName;
  });
  this.color = this._colorFromHashOfString(this.name);

  this.node.subscribe(function(oldNode) {
    if (oldNode) oldNode.removeRef(self);
  }, null, "beforeChange");
  this.node.subscribe(function(newNode) {
    if (newNode) newNode.pushRef(self);
  });

  // This optimization is for autocomplete display
  this.value = splitedName[splitedName.length - 1]
  this.label = this.localRefName
  this.dom = `${this.localRefName}<span class='octicon ${this.isTag ? 'octicon-tag' : 'octicon-git-branch'}'></span>`
};
module.exports = RefViewModel;

RefViewModel.prototype._colorFromHashOfString = function(string) {
  return '#' + md5(string).toString().slice(0, 6);
}
RefViewModel.prototype.dragStart = function() {
  this.graph.currentActionContext(this);
  this.isDragging(true);
  if (document.activeElement) document.activeElement.blur();
}
RefViewModel.prototype.dragEnd = function() {
  this.graph.currentActionContext(null);
  this.isDragging(false);
}
RefViewModel.prototype.moveTo = function(target, rewindWarnOverride) {
  var self = this;
  var promise;
  if (this.isLocal) {
    var toNode = this.graph.nodesById[target];
    var args = { path: self.graph.repoPath(), name: self.refName, sha1: target, force: true, to: target, mode: 'hard' };
    var operation;
    if (this.current()) {
      operation = '/reset';
    } else if (this.isTag) {
      operation = '/tags';
    } else {
      operation = '/branches';
    }

    if (!rewindWarnOverride && this.node().date > toNode.date) {
      promise = components.create('yesnodialog', { title: 'Are you sure?', details: 'This operation potentially going back in history.'})
        .show()
        .closeThen(function(diag) {
          if (diag.result()) {
            return self.server.postPromise(operation, args);
          }
        }).closePromise;
    } else {
      promise = self.server.postPromise(operation, args);
    }
  } else {
    var pushReq = { path: this.graph.repoPath(), remote: this.remote, refSpec: target, remoteBranch: this.refName };
    promise = this.server.postPromise('/push', pushReq)
      .catch(function(err) {
        if (err.errorCode == 'non-fast-forward') {
          return components.create('yesnodialog', { title: 'Force push?', details: 'The remote branch can\'t be fast-forwarded.' })
            .show()
            .closeThen(function(diag) {
              if (!diag.result()) return false;
              pushReq.force = true;
              return self.server.postPromise('/push', pushReq);
            }).closePromise;
        }
      });
  }

  return promise
    .then(function(res) {
      if (!res) return;
      var targetNode = self.graph.getNode(target);
      if (self.graph.checkedOutBranch() == self.refName) {
        self.graph.HEADref().node(targetNode);
      }
      self.node(targetNode);
    });
}

RefViewModel.prototype.remove = function() {
  var self = this;
  var url = this.isTag ? '/tags' : '/branches';
  if (this.isRemote) url = '/remote' + url;

  return this.server.delPromise(url, { path: this.graph.repoPath(), remote: this.isRemote ? this.remote : null, name: this.refName })
    .then(function() {
      self.node().removeRef(self);
      self.graph.refsByRefName[self.name] = undefined;
    }).finally(function() {
      if (url == '/remote/tags') {
        programEvents.dispatch({ event: 'request-fetch-tags' });
      } else {
        programEvents.dispatch({ event: 'branch-updated' });
      }
      return self.graph.loadNodesFromApi();
    });
}

RefViewModel.prototype.getLocalRef = function() {
  return this.graph.getRef(this.getLocalRefFullName(), false);
}
RefViewModel.prototype.getLocalRefFullName = function() {
  if (this.isRemoteBranch) return 'refs/heads/' + this.refName;
  if (this.isRemoteTag) return 'tag: ' + this.refName;
  return null;
}

RefViewModel.prototype.getRemoteRef = function(remote) {
  return this.graph.getRef(this.getRemoteRefFullName(remote), false);
}

RefViewModel.prototype.getRemoteRefFullName = function(remote) {
  if (this.isLocalBranch) return 'refs/remotes/' + remote + '/' + this.refName;
  if (this.isLocalTag) return 'remote-tag: ' + remote + '/' + this.refName;
  return null;
}

RefViewModel.prototype.canBePushed = function(remote) {
  if (!this.isLocal) return false;
  var remoteRef = this.getRemoteRef(remote);
  if (!remoteRef) return true;
  return this.node() != remoteRef.node();
}

RefViewModel.prototype.createRemoteRef = function() {
  var self = this;
  return this.server.postPromise('/push', { path: this.graph.repoPath(), remote: this.graph.currentRemote(),
    refSpec: this.refName, remoteBranch: this.refName }).then(function() {
      var newRef = self.graph.getRef("refs/remotes/" + self.graph.currentRemote() + "/" + self.refName);
      newRef.node(self.node());
    });
}

},{"./selectable":8,"bluebird":undefined,"blueimp-md5":"blueimp-md5","knockout":"knockout","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}],6:[function(require,module,exports){
var ko = require('knockout');
var components = require('ungit-components');
var GitNodeViewModel = require('./git-node');
var GitRefViewModel = require('./git-ref');
var _ = require('lodash');
var moment = require('moment');
var EdgeViewModel = require('./edge');
var numberOfNodesPerLoad = ungit.config.numberOfNodesPerLoad;

components.register('graph', function(args) {
  return new GraphViewModel(args.server, args.repoPath);
});

function GraphViewModel(server, repoPath) {
  var self = this;
  this.repoPath = repoPath;
  this.limit = ko.observable(numberOfNodesPerLoad);
  this.skip = ko.observable(0);
  this.server = server;
  this.currentRemote = ko.observable();
  this.nodesLoader = components.create('progressBar', {
    predictionMemoryKey: 'gitgraph-' + self.repoPath(),
    fallbackPredictedTimeMs: 1000,
    temporary: true
  });
  this.nodes = ko.observableArray();
  this.edges = ko.observableArray();
  this.refs = ko.observableArray();
  this.nodesById = {};
  this.refsByRefName = {};
  this.checkedOutBranch = ko.observable();
  this.checkedOutRef = ko.computed(function() {
    return self.checkedOutBranch() ? self.getRef('refs/heads/' + self.checkedOutBranch()) : null;
  });
  this.HEADref = ko.observable();
  this.HEAD = ko.computed(function() {
    return self.HEADref() ? self.HEADref().node() : undefined;
  });
  this.commitNodeColor = ko.computed(function() {
    return self.HEAD() ? self.HEAD().color() : '#4A4A4A';
  });
  this.commitNodeEdge = ko.computed(function() {
    if (!self.HEAD() || !self.HEAD().cx() || !self.HEAD().cy()) return;
    return "M 610 68 L " + self.HEAD().cx() + " " + self.HEAD().cy();
  });
  this.showCommitNode = ko.observable(false);
  this.currentActionContext = ko.observable();
  this.edgesById = {};
  this.scrolledToEnd = _.debounce(function() {
    self.limit(numberOfNodesPerLoad + self.limit());
    self.loadNodesFromApi();
  }, 500, true);
  this.loadAhead = _.debounce(function() {
    if (self.skip() <= 0) return;
    self.skip(Math.max(self.skip() - numberOfNodesPerLoad, 0));
    self.loadNodesFromApi();
  }, 500, true);
  this.dimCommit = ko.observable(false);
  this.commitOpacity = ko.computed(function() { return self.dimCommit() ? 0.1 : 1; });
  this.heighstBranchOrder = 0;
  this.hoverGraphActionGraphic = ko.observable();
  this.hoverGraphActionGraphic.subscribe(function(value) {
    if (value && value.destroy)
      value.destroy();
  }, null, 'beforeChange');

  this.hoverGraphAction = ko.observable();
  this.hoverGraphAction.subscribe(function(value) {
    if (value && value.createHoverGraphic) {
      self.hoverGraphActionGraphic(value.createHoverGraphic());
    } else {
      self.hoverGraphActionGraphic(null);
    }
  });

  this.loadNodesFromApiThrottled = _.throttle(this.loadNodesFromApi.bind(this), 1000);
  this.updateBranchesThrottled = _.throttle(this.updateBranches.bind(this), 1000);
  this.loadNodesFromApi();
  this.updateBranches();
  this.graphWidth = ko.observable();
  this.graphHeight = ko.observable(800);
}

GraphViewModel.prototype.updateNode = function(parentElement) {
  ko.renderTemplate('graph', this, {}, parentElement);
}

GraphViewModel.prototype.getNode = function(sha1, logEntry) {
  var nodeViewModel = this.nodesById[sha1];
  if (!nodeViewModel) nodeViewModel = this.nodesById[sha1] = new GitNodeViewModel(this, sha1);
  if (logEntry) nodeViewModel.setData(logEntry);
  return nodeViewModel;
}
GraphViewModel.prototype.getRef = function(ref, constructIfUnavailable) {
  if (constructIfUnavailable === undefined) constructIfUnavailable = true;
  var refViewModel = this.refsByRefName[ref];
  if (!refViewModel && constructIfUnavailable) {
    refViewModel = this.refsByRefName[ref] = new GitRefViewModel(ref, this);
    this.refs.push(refViewModel);
    if (refViewModel.name === 'HEAD') {
      this.HEADref(refViewModel);
    }
  }
  return refViewModel;
}

GraphViewModel.prototype.loadNodesFromApi = function() {
  var self = this;
  var nodeSize = self.nodes().length;

  this.nodesLoader.start();
  return this.server.getPromise('/log', { path: this.repoPath(), limit: this.limit(), skip: this.skip() })
    .then(function(log) {
      // set new limit and skip
      self.limit(parseInt(log.limit));
      self.skip(parseInt(log.skip));
      return log.nodes || [];
    }).then(function(nodes) {
      // check for deleted refs to update the UI
      var updatedRefs = [];
      nodes.forEach(function(logEntry) {
        updatedRefs = updatedRefs.concat(logEntry.refs);
      });
      Object.keys(self.refsByRefName).forEach(function(refName) {
        if (updatedRefs.indexOf(refName) < 0) {
          self.refs.remove(self.refsByRefName[refName]);
          var ref = self.refsByRefName[refName];
          if (ref) { ref.node(null); }
          delete self.refsByRefName[refName]
        }
      });
      return nodes;
    }).then(function(nodes) {
      // create and/or calculate nodes
      return self.computeNode(nodes.map(function(logEntry) {
        return self.getNode(logEntry.sha1, logEntry);
      }));
    }).then(function(nodes) {
      // create edges
      var edges = [];
      nodes.forEach(function(node) {
        node.parents().forEach(function(parentSha1) {
          edges.push(self.getEdge(node.sha1, parentSha1));
        });
        node.render();
      });

      self.edges(edges);
      self.nodes(nodes);
      if (nodes.length > 0) {
        self.graphHeight(nodes[nodes.length - 1].cy() + 80);
      }
      self.graphWidth(1000 + (self.heighstBranchOrder * 90));
    }).finally(function() {
      self.nodesLoader.stop();
      if (window.innerHeight - self.graphHeight() > 0 && nodeSize != self.nodes().length) {
        self.scrolledToEnd();
      }
    });
}

GraphViewModel.prototype.traverseNodeLeftParents = function(node, callback) {
  callback(node);
  var parent = this.nodesById[node.parents()[0]];
  if (parent) {
    this.traverseNodeLeftParents(parent, callback);
  }
}

GraphViewModel.prototype.computeNode = function(nodes) {
  var self = this;

  nodes = nodes || this.nodes();

  this.markNodesIdeologicalBranches(this.refs(), nodes, this.nodesById);

  var updateTimeStamp = moment().valueOf();
  if (this.HEAD()) {
    this.traverseNodeLeftParents(this.HEAD(), function(node) {
      node.ancestorOfHEADTimeStamp = updateTimeStamp;
    });
  }

  // Filter out nodes which doesn't have a branch (staging and orphaned nodes)
  nodes = nodes.filter(function(node) {
    return (node.ideologicalBranch() && !node.ideologicalBranch().isStash) || node.ancestorOfHEADTimeStamp == updateTimeStamp;
  });

  var branchSlotCounter = this.HEAD() ? 1 : 0;

  // Then iterate from the bottom to fix the orders of the branches
  for (var i = nodes.length - 1; i >= 0; i--) {
    var node = nodes[i];
    if (node.ancestorOfHEADTimeStamp == updateTimeStamp) continue;
    var ideologicalBranch = node.ideologicalBranch();

    // First occurence of the branch, find an empty slot for the branch
    if (ideologicalBranch.lastSlottedTimeStamp != updateTimeStamp) {
      ideologicalBranch.lastSlottedTimeStamp = updateTimeStamp;
      ideologicalBranch.branchOrder = branchSlotCounter++
    }

    node.branchOrder(ideologicalBranch.branchOrder);
  }

  self.heighstBranchOrder = branchSlotCounter - 1;
  var prevNode;
  nodes.forEach(function(node) {
    node.ancestorOfHEAD(node.ancestorOfHEADTimeStamp == updateTimeStamp);
    if (node.ancestorOfHEAD()) node.branchOrder(0);
    node.aboveNode = prevNode;
    if (prevNode) prevNode.belowNode = node;
    prevNode = node;
  });

  return nodes;
}

GraphViewModel.prototype.getEdge = function(nodeAsha1, nodeBsha1) {
  var id = nodeAsha1 + '-' + nodeBsha1;
  var edge = this.edgesById[id];
  if (!edge) {
    edge = this.edgesById[id] = new EdgeViewModel(this, nodeAsha1, nodeBsha1);
  }
  return edge;
}

GraphViewModel._markIdeologicalStamp = 0;
GraphViewModel.prototype.markNodesIdeologicalBranches = function(refs, nodes, nodesById) {
  var self = this;
  refs = refs.filter(function(r) { return !!r.node(); });
  refs = refs.sort(function(a, b) {
    if (a.isLocal && !b.isLocal) return -1;
    if (b.isLocal && !a.isLocal) return 1;
    if (a.isBranch && !b.isBranch) return -1;
    if (b.isBranch && !a.isBranch) return 1;
    if (a.isHEAD && !b.isHEAD) return 1;
    if (!a.isHEAD && b.isHEAD) return -1;
    if (a.isStash && !b.isStash) return 1;
    if (b.isStash && !a.isStash) return -1;
    if (a.node() && a.node().date && b.node() && b.node().date)
      return a.node().date - b.node().date;
    return a.refName < b.refName ? -1 : 1;
  });
  var stamp = GraphViewModel._markIdeologicalStamp++;
  refs.forEach(function(ref) {
    self.traverseNodeParents(ref.node(), function(node) {
      if (node.stamp == stamp) return false;
      node.stamp = stamp;
      node.ideologicalBranch(ref);
      return true;
    });
  });
}

GraphViewModel.prototype.traverseNodeParents = function(node, callback) {
  if (!callback(node)) return false;
  for (var i = 0; i < node.parents().length; i++) {
    // if parent, travers parent
    var parent = this.nodesById[node.parents()[i]];
    if (parent) {
      this.traverseNodeParents(parent, callback);
    }
  }
}

GraphViewModel.prototype.handleBubbledClick = function(elem, event) {
  // If the clicked element is bound to the current action context,
  // then let's not deselect it.
  if (ko.dataFor(event.target) === this.currentActionContext()) return;
  if (this.currentActionContext() && this.currentActionContext() instanceof GitNodeViewModel) {
    this.currentActionContext().toggleSelected();
  } else {
    this.currentActionContext(null);
  }
  // If the click was on an input element, then let's allow the default action to proceed.
  // This is especially needed since for some strange reason any submit (ie. enter in a textbox)
  // will trigger a click event on the submit input of the form, which will end up here,
  // and if we don't return true, then the submit event is never fired, breaking stuff.
  if (event.target.nodeName === 'INPUT') return true;
}

GraphViewModel.prototype.onProgramEvent = function(event) {
  if (event.event == 'git-directory-changed') {
    this.loadNodesFromApiThrottled();
    this.updateBranchesThrottled();
  } else if (event.event == 'request-app-content-refresh') {
    this.loadNodesFromApiThrottled();
  } else if (event.event == 'remote-tags-update') {
    this.setRemoteTags(event.tags);
  } else if (event.event == 'current-remote-changed') {
    this.currentRemote(event.newRemote);
  } else if (event.event == 'graph-render') {
    this.nodes().forEach(function(node) {
      node.render();
    });
  }
}
GraphViewModel.prototype.updateBranches = function() {
  var self = this;

  this.server.getPromise('/checkout', { path: this.repoPath() })
    .then(function(res) { self.checkedOutBranch(res); })
    .catch(function(err) {
      if (err.errorCode != 'not-a-repository') throw err;
    })
}
GraphViewModel.prototype.setRemoteTags = function(remoteTags) {
  var self = this;
  var nodeIdsToRemoteTags = {};
  remoteTags.forEach(function(ref) {
    if (ref.name.indexOf('^{}') != -1) {
      var tagRef = ref.name.slice(0, ref.name.length - '^{}'.length);
      var name = 'remote-tag: ' + ref.remote + '/' + tagRef.split('/')[2];
      self.getRef(name).node(self.getNode(ref.sha1));
    }
  });
}
GraphViewModel.prototype.checkHeadMove = function(toNode) {
  if (this.HEAD() === toNode) {
    this.HEADref.node(toNode);
  }
}

},{"./edge":2,"./git-node":4,"./git-ref":5,"knockout":"knockout","lodash":"lodash","moment":"moment","ungit-components":"ungit-components"}],7:[function(require,module,exports){
var getEdgeModelWithD = function(d, stroke, strokeWidth, strokeDasharray, markerEnd) {
  return { d: d,
          stroke: stroke ? stroke : '#4A4A4A',
          strokeWidth: strokeWidth ? strokeWidth : '8',
          strokeDasharray: strokeDasharray ? strokeDasharray : '10, 5',
          markerEnd: markerEnd ? markerEnd : '' };
}

var getEdgeModel = function(scx, scy, tcx, tcy, stroke, strokeWidth, strokeDasharray, markerEnd) {
  return getEdgeModelWithD("M " + scx + " " + scy + " L " + tcx + " " + tcy, stroke, strokeWidth, strokeDasharray, markerEnd);
}

var getNodeModel = function(cx, cy, r, fill, stroke, strokeWidth, strokeDasharray) {
  return { cx: cx,
          cy: cy,
          r: r,
          fill: fill,
          stroke: stroke ? stroke : '#41DE3C',
          strokeWidth: strokeWidth ? strokeWidth : '8',
          strokeDasharray: strokeDasharray ? strokeDasharray : '10, 5' };
}

function HoverViewModel() {
  this.bgEdges = [];
  this.nodes = [];
  this.fgEdges = [];
}

function MergeViewModel(graph, headNode, node) {
  var self = this;
  HoverViewModel.call(this);
  this.graph = graph;
  this.bgEdges = [ getEdgeModel(headNode.cx(), (headNode.cy() - 110), headNode.cx(), headNode.cy()),
                getEdgeModel(headNode.cx(), (headNode.cy() - 110), node.cx(), node.cy()) ];
  this.nodes = [ getNodeModel(headNode.cx(), headNode.cy() - 110, Math.max(headNode.r(), node.r()), '#252833', '#41DE3C', '8', '10, 5') ];

  graph.dimCommit(true);
}
exports.MergeViewModel = MergeViewModel;
MergeViewModel.prototype.destroy = function() {
  this.graph.dimCommit(false);
}

function RebaseViewModel(onto, nodesThatWillMove) {
  var self = this;
  HoverViewModel.call(this);
  nodesThatWillMove = nodesThatWillMove.slice(0, -1);

  if (nodesThatWillMove.length == 0) return;

  this.bgEdges.push(getEdgeModel(onto.cx(), onto.cy(), onto.cx(), onto.cy() - 60));
  nodesThatWillMove.forEach(function(node, i) {
    var cy = onto.cy() + (-90 * (i + 1));
    self.nodes.push(getNodeModel(onto.cx(), cy, 28, 'transparent'));
    if (i + 1 < nodesThatWillMove.length) {
      self.bgEdges.push(getEdgeModel(onto.cx(), (cy - 25), onto.cx(), (cy - 65)));
    }
  });
}
exports.RebaseViewModel = RebaseViewModel;

function ResetViewModel(nodes) {
  var self = this;
  HoverViewModel.call(this);

  nodes.forEach(function(node) {
    self.fgEdges.push(getEdgeModelWithD(node.getLeftToRightStrike(), 'rgb(255, 129, 31)', '8', '0, 0'))
    self.fgEdges.push(getEdgeModelWithD(node.getRightToLeftStrike(), 'rgb(255, 129, 31)', '8', '0, 0'));
  });
}
exports.ResetViewModel = ResetViewModel;

function PushViewModel(fromNode, toNode) {
  HoverViewModel.call(this);
  this.fgEdges = [getEdgeModel(fromNode.cx(), fromNode.cy(), toNode.cx(), (toNode.cy() + 40), 'rgb(61, 139, 255)', '15', '10, 5', 'url(#pushArrowEnd)' )];
}
exports.PushViewModel = PushViewModel;

function SquashViewModel(from, onto) {
  HoverViewModel.call(this);

  let path = from.getPathToCommonAncestor(onto);

  if (path.length == 0) {
    return;
  } else if (path.length == 1) {
    path = onto.getPathToCommonAncestor(from)
  } else {
    this.nodes.push(getNodeModel(onto.cx(), onto.cy() - 120, 28, 'transparent'));
  }

  path.slice(0, -1).forEach((node) => {
    this.nodes.push(getNodeModel(node.cx(), node.cy(), node.r() + 2, 'rgba(100, 60, 222, 0.8)'));
  });
}
exports.SquashViewModel = SquashViewModel;

},{}],8:[function(require,module,exports){
var ko = require('knockout');

var Selectable = function(graph) {
  this.selected = ko.computed({
    read: function() {
      return graph.currentActionContext() == this;
    },
    write: function(val) {
      // val is this if we're called from a click ko binding
      if (val === this || val === true) {
        graph.currentActionContext(this);
      } else if (graph.currentActionContext() == this) {
        graph.currentActionContext(null);
      }
    },
    owner: this
  });
};
module.exports = Selectable;

},{"knockout":"knockout"}]},{},[6])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL2dyYXBoL2FuaW1hdGVhYmxlLmpzIiwiY29tcG9uZW50cy9ncmFwaC9lZGdlLmpzIiwiY29tcG9uZW50cy9ncmFwaC9naXQtZ3JhcGgtYWN0aW9ucy5qcyIsImNvbXBvbmVudHMvZ3JhcGgvZ2l0LW5vZGUuanMiLCJjb21wb25lbnRzL2dyYXBoL2dpdC1yZWYuanMiLCJjb21wb25lbnRzL2dyYXBoL2dyYXBoLmpzIiwiY29tcG9uZW50cy9ncmFwaC9ob3Zlci1hY3Rpb25zLmpzIiwiY29tcG9uZW50cy9ncmFwaC9zZWxlY3RhYmxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2paQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5yZXF1aXJlKCdtaW5hJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmVsZW1lbnQgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMucHJldmlvdXNHcmFwaCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5lbGVtZW50LnN1YnNjcmliZShmdW5jdGlvbih2YWwpIHtcbiAgICBpZiAodmFsKSBzZWxmLmFuaW1hdGUodHJ1ZSk7XG4gIH0pO1xuICB0aGlzLmFuaW1hdGUgPSBmdW5jdGlvbihmb3JjZVJlZnJlc2gpIHtcbiAgICB2YXIgY3VycmVudEdyYXBoID0gdGhpcy5nZXRHcmFwaEF0dHIoKTtcbiAgICAvLyBhbmltYXRlIG9ubHkgd2hlbiBkb20gaXMgdmFsaWQgYW5kIChhdHRyaWJ1dGUgY2hhbmdlZCBvciBmb3JjZSByZWZyZXNoIGR1ZSB0byBkb20gY2hhbmdlKVxuICAgIGlmICh0aGlzLmVsZW1lbnQoKSAmJiAoZm9yY2VSZWZyZXNoIHx8IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRHcmFwaCkgIT09IEpTT04uc3RyaW5naWZ5KHRoaXMucHJldmlvdXNHcmFwaCkpKSB7XG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIHdpbmRvdy5taW5hKHRoaXMucHJldmlvdXNHcmFwaCB8fCBjdXJyZW50R3JhcGgsIGN1cnJlbnRHcmFwaCwgbm93LCBub3cgKyA3NTAsIHdpbmRvdy5taW5hLnRpbWUsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgc2VsZi5zZXRHcmFwaEF0dHIodmFsKTtcbiAgICAgIH0sIHdpbmRvdy5taW5hLmVsYXN0aWMpO1xuICAgICAgdGhpcy5wcmV2aW91c0dyYXBoID0gY3VycmVudEdyYXBoO1xuICAgIH1cbiAgfVxufTtcbiIsInZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG52YXIgQW5pbWF0ZWFibGUgPSByZXF1aXJlKCcuL2FuaW1hdGVhYmxlJyk7XG5cbnZhciBFZGdlVmlld01vZGVsID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGVBc2hhMSwgbm9kZUJzaGExKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgQW5pbWF0ZWFibGUuY2FsbCh0aGlzKTtcbiAgdGhpcy5ub2RlQSA9IGdyYXBoLmdldE5vZGUobm9kZUFzaGExKTtcbiAgdGhpcy5ub2RlQiA9IGdyYXBoLmdldE5vZGUobm9kZUJzaGExKTtcbiAgdGhpcy5nZXRHcmFwaEF0dHIgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi5ub2RlQS5pc1ZpZXdhYmxlKCkgJiYgKCFzZWxmLm5vZGVCLmlzVmlld2FibGUoKSB8fCAhc2VsZi5ub2RlQi5pc0luaXRlZCkpIHtcbiAgICAgIHJldHVybiBbc2VsZi5ub2RlQS5jeCgpLCBzZWxmLm5vZGVBLmN5KCksIHNlbGYubm9kZUEuY3goKSwgc2VsZi5ub2RlQS5jeSgpLFxuICAgICAgICAgICAgICBzZWxmLm5vZGVBLmN4KCksIGdyYXBoLmdyYXBoSGVpZ2h0KCksIHNlbGYubm9kZUEuY3goKSwgZ3JhcGguZ3JhcGhIZWlnaHQoKV07XG4gICAgfSBlbHNlIGlmIChzZWxmLm5vZGVCLmlzSW5pdGVkICYmIHNlbGYubm9kZUIuY3goKSAmJiBzZWxmLm5vZGVCLmN5KCkpIHtcbiAgICAgIHJldHVybiBbc2VsZi5ub2RlQS5jeCgpLCBzZWxmLm5vZGVBLmN5KCksIHNlbGYubm9kZUEuY3goKSwgc2VsZi5ub2RlQS5jeSgpLFxuICAgICAgICAgICAgICBzZWxmLm5vZGVCLmN4KCksIHNlbGYubm9kZUIuY3koKSwgc2VsZi5ub2RlQi5jeCgpLCBzZWxmLm5vZGVCLmN5KCldO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIH1cbiAgfSk7XG4gIHRoaXMuZ2V0R3JhcGhBdHRyLnN1YnNjcmliZSh0aGlzLmFuaW1hdGUuYmluZCh0aGlzKSk7XG59XG5FZGdlVmlld01vZGVsLnByb3RvdHlwZS5zZXRHcmFwaEF0dHIgPSBmdW5jdGlvbih2YWwpIHtcbiAgdGhpcy5lbGVtZW50KCkuc2V0QXR0cmlidXRlKCdkJywgJ00nICsgdmFsLnNsaWNlKDAsNCkuam9pbignLCcpICsgJ0wnICsgdmFsLnNsaWNlKDQsOCkuam9pbignLCcpKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRWRnZVZpZXdNb2RlbDtcbiIsIlxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcbnZhciBjb21wb25lbnRzID0gcmVxdWlyZSgndW5naXQtY29tcG9uZW50cycpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xudmFyIFJlZlZpZXdNb2RlbCA9IHJlcXVpcmUoJy4vZ2l0LXJlZi5qcycpO1xudmFyIEhvdmVyQWN0aW9ucyA9IHJlcXVpcmUoJy4vaG92ZXItYWN0aW9ucycpO1xudmFyIFJlYmFzZVZpZXdNb2RlbCA9IEhvdmVyQWN0aW9ucy5SZWJhc2VWaWV3TW9kZWw7XG52YXIgTWVyZ2VWaWV3TW9kZWwgPSBIb3ZlckFjdGlvbnMuTWVyZ2VWaWV3TW9kZWw7XG52YXIgUmVzZXRWaWV3TW9kZWwgPSBIb3ZlckFjdGlvbnMuUmVzZXRWaWV3TW9kZWw7XG52YXIgUHVzaFZpZXdNb2RlbCA9IEhvdmVyQWN0aW9ucy5QdXNoVmlld01vZGVsO1xudmFyIFNxdWFzaFZpZXdNb2RlbCA9IEhvdmVyQWN0aW9ucy5TcXVhc2hWaWV3TW9kZWw7XG5cbnZhciBHcmFwaEFjdGlvbnMgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gR3JhcGhBY3Rpb25zO1xuXG5HcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICB0aGlzLnNlcnZlciA9IGdyYXBoLnNlcnZlcjtcbiAgdGhpcy5wZXJmb3JtUHJvZ3Jlc3NCYXIgPSBjb21wb25lbnRzLmNyZWF0ZSgncHJvZ3Jlc3NCYXInLCB7XG4gICAgcHJlZGljdGlvbk1lbW9yeUtleTogJ2FjdGlvbi0nICsgdGhpcy5zdHlsZSArICctJyArIGdyYXBoLnJlcG9QYXRoKCksXG4gICAgZmFsbGJhY2tQcmVkaWN0ZWRUaW1lTXM6IDEwMDAsXG4gICAgdGVtcG9yYXJ5OiB0cnVlXG4gIH0pO1xuXG4gIHRoaXMuaXNIaWdobGlnaHRlZCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhZ3JhcGguaG92ZXJHcmFwaEFjdGlvbigpIHx8IGdyYXBoLmhvdmVyR3JhcGhBY3Rpb24oKSA9PSBzZWxmO1xuICB9KTtcbiAgdGhpcy5jc3NDbGFzc2VzID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGMgPSBzZWxmLnN0eWxlO1xuICAgIGlmICghc2VsZi5pc0hpZ2hsaWdodGVkKCkpIGMgKz0gJyBkaW1tZWQnO1xuICAgIHJldHVybiBjO1xuICB9KVxufVxuR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UucHJvdG90eXBlLmljb24gPSBudWxsO1xuR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UucHJvdG90eXBlLmRvUGVyZm9ybSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuZ3JhcGguaG92ZXJHcmFwaEFjdGlvbihudWxsKTtcbiAgc2VsZi5wZXJmb3JtUHJvZ3Jlc3NCYXIuc3RhcnQoKTtcbiAgdGhpcy5wZXJmb3JtKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICBzZWxmLnBlcmZvcm1Qcm9ncmVzc0Jhci5zdG9wKCk7XG4gIH0pO1xufVxuR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UucHJvdG90eXBlLmRyYWdFbnRlciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMudmlzaWJsZSgpKSByZXR1cm47XG4gIHRoaXMuZ3JhcGguaG92ZXJHcmFwaEFjdGlvbih0aGlzKTtcbn1cbkdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLnByb3RvdHlwZS5kcmFnTGVhdmUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnZpc2libGUoKSkgcmV0dXJuO1xuICB0aGlzLmdyYXBoLmhvdmVyR3JhcGhBY3Rpb24obnVsbCk7XG59XG5HcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5wcm90b3R5cGUubW91c2VvdmVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZ3JhcGguaG92ZXJHcmFwaEFjdGlvbih0aGlzKTtcbn1cbkdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLnByb3RvdHlwZS5tb3VzZW91dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdyYXBoLmhvdmVyR3JhcGhBY3Rpb24obnVsbCk7XG59XG5cbkdyYXBoQWN0aW9ucy5Nb3ZlID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCAmJlxuICAgICAgc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLm5vZGUoKSAhPSBzZWxmLm5vZGU7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLk1vdmUsIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5Nb3ZlLnByb3RvdHlwZS50ZXh0ID0gJ01vdmUnO1xuR3JhcGhBY3Rpb25zLk1vdmUucHJvdG90eXBlLnN0eWxlID0gJ21vdmUnO1xuR3JhcGhBY3Rpb25zLk1vdmUucHJvdG90eXBlLmljb24gPSAnZ2x5cGhpY29uIGdseXBoaWNvbi1tb3ZlJztcbkdyYXBoQWN0aW9ucy5Nb3ZlLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkubW92ZVRvKHRoaXMubm9kZS5zaGExKTtcbn1cblxuR3JhcGhBY3Rpb25zLlJlc2V0ID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCEoc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgUmVmVmlld01vZGVsKSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBjb250ZXh0ID0gc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICAgIGlmIChjb250ZXh0Lm5vZGUoKSAhPSBzZWxmLm5vZGUpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcmVtb3RlUmVmID0gY29udGV4dC5nZXRSZW1vdGVSZWYoc2VsZi5ncmFwaC5jdXJyZW50UmVtb3RlKCkpO1xuICAgIHJldHVybiByZW1vdGVSZWYgJiYgcmVtb3RlUmVmLm5vZGUoKSAmJlxuICAgICAgY29udGV4dCAmJiBjb250ZXh0Lm5vZGUoKSAmJlxuICAgICAgcmVtb3RlUmVmLm5vZGUoKSAhPSBjb250ZXh0Lm5vZGUoKSAmJlxuICAgICAgcmVtb3RlUmVmLm5vZGUoKS5kYXRlIDwgY29udGV4dC5ub2RlKCkuZGF0ZTtcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuUmVzZXQsIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5SZXNldC5wcm90b3R5cGUudGV4dCA9ICdSZXNldCc7XG5HcmFwaEFjdGlvbnMuUmVzZXQucHJvdG90eXBlLnN0eWxlID0gJ3Jlc2V0JztcbkdyYXBoQWN0aW9ucy5SZXNldC5wcm90b3R5cGUuaWNvbiA9ICdnbHlwaGljb24gZ2x5cGhpY29uLXRyYXNoJztcbkdyYXBoQWN0aW9ucy5SZXNldC5wcm90b3R5cGUuY3JlYXRlSG92ZXJHcmFwaGljID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICBpZiAoIWNvbnRleHQpIHJldHVybiBudWxsO1xuICB2YXIgcmVtb3RlUmVmID0gY29udGV4dC5nZXRSZW1vdGVSZWYodGhpcy5ncmFwaC5jdXJyZW50UmVtb3RlKCkpO1xuICB2YXIgbm9kZXMgPSBjb250ZXh0Lm5vZGUoKS5nZXRQYXRoVG9Db21tb25BbmNlc3RvcihyZW1vdGVSZWYubm9kZSgpKS5zbGljZSgwLCAtMSk7XG4gIHJldHVybiBuZXcgUmVzZXRWaWV3TW9kZWwobm9kZXMpO1xufVxuR3JhcGhBY3Rpb25zLlJlc2V0LnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNvbnRleHQgPSB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gIHZhciByZW1vdGVSZWYgPSBjb250ZXh0LmdldFJlbW90ZVJlZihzZWxmLmdyYXBoLmN1cnJlbnRSZW1vdGUoKSk7XG4gIHJldHVybiBjb21wb25lbnRzLmNyZWF0ZSgneWVzbm9kaWFsb2cnLCB7IHRpdGxlOiAnQXJlIHlvdSBzdXJlPycsIGRldGFpbHM6ICdSZXNldHRpbmcgdG8gcmVmOiAnICsgcmVtb3RlUmVmLm5hbWUgKyAnIGNhbm5vdCBiZSB1bmRvbmUgd2l0aCB1bmdpdC4nfSlcbiAgICAuc2hvdygpXG4gICAgLmNsb3NlVGhlbihmdW5jdGlvbihkaWFnKSB7XG4gICAgICBpZiAoIWRpYWcucmVzdWx0KCkpIHJldHVybjtcbiAgICAgIHJldHVybiBzZWxmLnNlcnZlci5wb3N0UHJvbWlzZSgnL3Jlc2V0JywgeyBwYXRoOiBzZWxmLmdyYXBoLnJlcG9QYXRoKCksIHRvOiByZW1vdGVSZWYubmFtZSwgbW9kZTogJ2hhcmQnIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkgeyBjb250ZXh0Lm5vZGUocmVtb3RlUmVmLm5vZGUoKSk7IH0pO1xuICAgIH0pLmNsb3NlUHJvbWlzZTtcbn1cblxuR3JhcGhBY3Rpb25zLlJlYmFzZSA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnBlcmZvcm1Qcm9ncmVzc0Jhci5ydW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwgJiZcbiAgICAgICghdW5naXQuY29uZmlnLnNob3dSZWJhc2VBbmRNZXJnZU9ubHlPblJlZnMgfHwgc2VsZi5ub2RlLnJlZnMoKS5sZW5ndGggPiAwKSAmJlxuICAgICAgc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLmN1cnJlbnQoKSAmJlxuICAgICAgc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLm5vZGUoKSAhPSBzZWxmLm5vZGU7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLlJlYmFzZSwgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UpO1xuR3JhcGhBY3Rpb25zLlJlYmFzZS5wcm90b3R5cGUudGV4dCA9ICdSZWJhc2UnO1xuR3JhcGhBY3Rpb25zLlJlYmFzZS5wcm90b3R5cGUuc3R5bGUgPSAncmViYXNlJztcbkdyYXBoQWN0aW9ucy5SZWJhc2UucHJvdG90eXBlLmljb24gPSAnb2N0aWNvbiBvY3RpY29uLXJlcG8tZm9ya2VkIGZsaXAnO1xuR3JhcGhBY3Rpb25zLlJlYmFzZS5wcm90b3R5cGUuY3JlYXRlSG92ZXJHcmFwaGljID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvbnRvID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICBpZiAoIW9udG8pIHJldHVybjtcbiAgaWYgKG9udG8gaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwpIG9udG8gPSBvbnRvLm5vZGUoKTtcbiAgdmFyIHBhdGggPSBvbnRvLmdldFBhdGhUb0NvbW1vbkFuY2VzdG9yKHRoaXMubm9kZSk7XG4gIHJldHVybiBuZXcgUmViYXNlVmlld01vZGVsKHRoaXMubm9kZSwgcGF0aCk7XG59XG5HcmFwaEFjdGlvbnMuUmViYXNlLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL3JlYmFzZScsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCBvbnRvOiB0aGlzLm5vZGUuc2hhMSB9KVxuICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHsgaWYgKGVyci5lcnJvckNvZGUgIT0gJ21lcmdlLWZhaWxlZCcpIHRocm93IGVycjsgfSlcbn1cblxuR3JhcGhBY3Rpb25zLk1lcmdlID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFzZWxmLmdyYXBoLmNoZWNrZWRPdXRSZWYoKSB8fCAhc2VsZi5ncmFwaC5jaGVja2VkT3V0UmVmKCkubm9kZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCAmJlxuICAgICAgIXNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5jdXJyZW50KCkgJiZcbiAgICAgIHNlbGYuZ3JhcGguY2hlY2tlZE91dFJlZigpLm5vZGUoKSA9PSBzZWxmLm5vZGU7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLk1lcmdlLCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuTWVyZ2UucHJvdG90eXBlLnRleHQgPSAnTWVyZ2UnO1xuR3JhcGhBY3Rpb25zLk1lcmdlLnByb3RvdHlwZS5zdHlsZSA9ICdtZXJnZSc7XG5HcmFwaEFjdGlvbnMuTWVyZ2UucHJvdG90eXBlLmljb24gPSAnb2N0aWNvbiBvY3RpY29uLWdpdC1tZXJnZSc7XG5HcmFwaEFjdGlvbnMuTWVyZ2UucHJvdG90eXBlLmNyZWF0ZUhvdmVyR3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwpIG5vZGUgPSBub2RlLm5vZGUoKTtcbiAgcmV0dXJuIG5ldyBNZXJnZVZpZXdNb2RlbCh0aGlzLmdyYXBoLCB0aGlzLm5vZGUsIG5vZGUpO1xufVxuR3JhcGhBY3Rpb25zLk1lcmdlLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL21lcmdlJywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksIHdpdGg6IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5sb2NhbFJlZk5hbWUgfSlcbiAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIuZXJyb3JDb2RlICE9ICdtZXJnZS1mYWlsZWQnKSB0aHJvdyBlcnI7IH0pXG59XG5cbkdyYXBoQWN0aW9ucy5QdXNoID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCAmJlxuICAgICAgc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLm5vZGUoKSA9PSBzZWxmLm5vZGUgJiZcbiAgICAgIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5jYW5CZVB1c2hlZChzZWxmLmdyYXBoLmN1cnJlbnRSZW1vdGUoKSk7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLlB1c2gsIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5QdXNoLnByb3RvdHlwZS50ZXh0ID0gJ1B1c2gnO1xuR3JhcGhBY3Rpb25zLlB1c2gucHJvdG90eXBlLnN0eWxlID0gJ3B1c2gnO1xuR3JhcGhBY3Rpb25zLlB1c2gucHJvdG90eXBlLmljb24gPSAnb2N0aWNvbiBvY3RpY29uLWNsb3VkLXVwbG9hZCc7XG5HcmFwaEFjdGlvbnMuUHVzaC5wcm90b3R5cGUuY3JlYXRlSG92ZXJHcmFwaGljID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICBpZiAoIWNvbnRleHQpIHJldHVybiBudWxsO1xuICB2YXIgcmVtb3RlUmVmID0gY29udGV4dC5nZXRSZW1vdGVSZWYodGhpcy5ncmFwaC5jdXJyZW50UmVtb3RlKCkpO1xuICBpZiAoIXJlbW90ZVJlZikgcmV0dXJuIG51bGw7XG4gIHJldHVybiBuZXcgUHVzaFZpZXdNb2RlbChyZW1vdGVSZWYubm9kZSgpLCBjb250ZXh0Lm5vZGUoKSk7XG59XG5HcmFwaEFjdGlvbnMuUHVzaC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZWYgPSB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gIHZhciByZW1vdGVSZWYgPSByZWYuZ2V0UmVtb3RlUmVmKHRoaXMuZ3JhcGguY3VycmVudFJlbW90ZSgpKTtcblxuICBpZiAocmVtb3RlUmVmKSB7XG4gICAgcmV0dXJuIHJlbW90ZVJlZi5tb3ZlVG8ocmVmLm5vZGUoKS5zaGExKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZWYuY3JlYXRlUmVtb3RlUmVmKClcbiAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc2VsZi5ncmFwaC5IRUFEKCkubmFtZSA9PSByZWYubmFtZSkge1xuICAgICAgICAgIHNlbGYuZ3JhaC5IRUFEcmVmKCkubm9kZShyZWYubm9kZSgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cbn1cblxuR3JhcGhBY3Rpb25zLkNoZWNrb3V0ID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbClcbiAgICAgIHJldHVybiBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkubm9kZSgpID09IHNlbGYubm9kZSAmJlxuICAgICAgICAhc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLmN1cnJlbnQoKTtcbiAgICByZXR1cm4gdW5naXQuY29uZmlnLmFsbG93Q2hlY2tvdXROb2RlcyAmJlxuICAgICAgc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpID09IHNlbGYubm9kZTtcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuQ2hlY2tvdXQsIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5DaGVja291dC5wcm90b3R5cGUudGV4dCA9ICdDaGVja291dCc7XG5HcmFwaEFjdGlvbnMuQ2hlY2tvdXQucHJvdG90eXBlLnN0eWxlID0gJ2NoZWNrb3V0JztcbkdyYXBoQWN0aW9ucy5DaGVja291dC5wcm90b3R5cGUuaWNvbiA9ICdvY3RpY29uIG9jdGljb24tZGVza3RvcC1kb3dubG9hZCc7XG5HcmFwaEFjdGlvbnMuQ2hlY2tvdXQucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY29udGV4dCA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgdmFyIHJlZk5hbWUgPSBjb250ZXh0IGluc3RhbmNlb2YgUmVmVmlld01vZGVsID8gY29udGV4dC5yZWZOYW1lIDogY29udGV4dC5zaGExO1xuXG4gIHZhciBtb3ZlUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB2YXIgaXNSZW1vdGUgPSBjb250ZXh0IGluc3RhbmNlb2YgUmVmVmlld01vZGVsICYmIGNvbnRleHQuaXNSZW1vdGVCcmFuY2g7XG4gIHZhciBpc0xvY2FsQ3VycmVudCA9IGNvbnRleHQuZ2V0TG9jYWxSZWYoKSAmJiBjb250ZXh0LmdldExvY2FsUmVmKCkuY3VycmVudCgpO1xuICBpZiAoaXNSZW1vdGUgJiYgIWlzTG9jYWxDdXJyZW50KSB7XG4gICAgbW92ZVByb21pc2UgPSB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL2JyYW5jaGVzJywge1xuICAgICAgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLFxuICAgICAgbmFtZTogY29udGV4dC5yZWZOYW1lLFxuICAgICAgc2hhMTogY29udGV4dC5uYW1lLFxuICAgICAgZm9yY2U6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9jaGVja291dCcsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCBuYW1lOiByZWZOYW1lIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoaXNSZW1vdGUgJiYgaXNMb2NhbEN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc2VydmVyLnBvc3RQcm9taXNlKCcvcmVzZXQnLCB7IHBhdGg6IHNlbGYuZ3JhcGgucmVwb1BhdGgoKSwgdG86IGNvbnRleHQubmFtZSwgbW9kZTogJ2hhcmQnIH0pXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmdyYXBoLkhFQURyZWYoKS5ub2RlKGNvbnRleHQgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwgPyBjb250ZXh0Lm5vZGUoKSA6IGNvbnRleHQpO1xuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5lcnJvckNvZGUgPT0gJ21lcmdlLWZhaWxlZCcpIHRocm93IGVyclxuICAgICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmdyYXBoLkhFQURyZWYoKS5ub2RlKGNvbnRleHQgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwgPyBjb250ZXh0Lm5vZGUoKSA6IGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVyci5lcnJvckNvZGUgIT0gJ21lcmdlLWZhaWxlZCcpIHsgdGhyb3cgZXJyOyB9XG4gICAgfSk7XG59XG5cbkdyYXBoQWN0aW9ucy5EZWxldGUgPSBmdW5jdGlvbihncmFwaCwgbm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLnZpc2libGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi5wZXJmb3JtUHJvZ3Jlc3NCYXIucnVubmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgUmVmVmlld01vZGVsICYmXG4gICAgICBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkubm9kZSgpID09IHNlbGYubm9kZSAmJlxuICAgICAgIXNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5jdXJyZW50KCk7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLkRlbGV0ZSwgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UpO1xuR3JhcGhBY3Rpb25zLkRlbGV0ZS5wcm90b3R5cGUudGV4dCA9ICdEZWxldGUnO1xuR3JhcGhBY3Rpb25zLkRlbGV0ZS5wcm90b3R5cGUuc3R5bGUgPSAnZGVsZXRlJztcbkdyYXBoQWN0aW9ucy5EZWxldGUucHJvdG90eXBlLmljb24gPSAnZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmUnO1xuR3JhcGhBY3Rpb25zLkRlbGV0ZS5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29udGV4dCA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgdmFyIG5hbWUgPSBjb250ZXh0LmlzUmVtb3RlQnJhbmNoID8gXCJyZW1vdGUgXCIgKyBjb250ZXh0LmxvY2FsUmVmTmFtZSA6IGNvbnRleHQubG9jYWxSZWZOYW1lO1xuICByZXR1cm4gY29tcG9uZW50cy5jcmVhdGUoJ3llc25vZGlhbG9nJywgeyB0aXRsZTogJ0FyZSB5b3Ugc3VyZT8nLCBkZXRhaWxzOiAnRGVsZXRpbmcgJyArIG5hbWUgKyAnIGJyYW5jaCBvciB0YWcgY2Fubm90IGJlIHVuZG9uZSB3aXRoIHVuZ2l0Lid9KVxuICAgIC5zaG93KClcbiAgICAuY2xvc2VUaGVuKGZ1bmN0aW9uKGRpYWcpIHtcbiAgICAgIGlmIChkaWFnLnJlc3VsdCgpKSByZXR1cm4gY29udGV4dC5yZW1vdmUoKTtcbiAgICB9KS5jbG9zZVByb21pc2U7XG59XG5cbkdyYXBoQWN0aW9ucy5DaGVycnlQaWNrID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgdmFyIGNvbnRleHQgPSBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gICAgcmV0dXJuIGNvbnRleHQgPT09IHNlbGYubm9kZSAmJiBzZWxmLmdyYXBoLkhFQUQoKSAmJiBjb250ZXh0LnNoYTEgIT09IHNlbGYuZ3JhcGguSEVBRCgpLnNoYTFcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuQ2hlcnJ5UGljaywgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UpO1xuR3JhcGhBY3Rpb25zLkNoZXJyeVBpY2sucHJvdG90eXBlLnRleHQgPSAnQ2hlcnJ5IHBpY2snO1xuR3JhcGhBY3Rpb25zLkNoZXJyeVBpY2sucHJvdG90eXBlLnN0eWxlID0gJ2NoZXJyeS1waWNrJztcbkdyYXBoQWN0aW9ucy5DaGVycnlQaWNrLnByb3RvdHlwZS5pY29uID0gJ29jdGljb24gb2N0aWNvbi1jaXJjdWl0LWJvYXJkJztcbkdyYXBoQWN0aW9ucy5DaGVycnlQaWNrLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvY2hlcnJ5cGljaycsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCBuYW1lOiB0aGlzLm5vZGUuc2hhMSB9KVxuICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHsgaWYgKGVyci5lcnJvckNvZGUgIT0gJ21lcmdlLWZhaWxlZCcpIHRocm93IGVycjsgfSlcbn1cblxuR3JhcGhBY3Rpb25zLlVuY29tbWl0ID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSA9PSBzZWxmLm5vZGUgJiZcbiAgICAgIHNlbGYuZ3JhcGguSEVBRCgpID09IHNlbGYubm9kZTtcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuVW5jb21taXQsIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5VbmNvbW1pdC5wcm90b3R5cGUudGV4dCA9ICdVbmNvbW1pdCc7XG5HcmFwaEFjdGlvbnMuVW5jb21taXQucHJvdG90eXBlLnN0eWxlID0gJ3VuY29tbWl0JztcbkdyYXBoQWN0aW9ucy5VbmNvbW1pdC5wcm90b3R5cGUuaWNvbiA9ICdvY3RpY29uIG9jdGljb24temFwJztcbkdyYXBoQWN0aW9ucy5VbmNvbW1pdC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL3Jlc2V0JywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksIHRvOiAnSEVBRF4nLCBtb2RlOiAnbWl4ZWQnIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGFyZ2V0Tm9kZSA9IHNlbGYubm9kZS5iZWxvd05vZGU7XG4gICAgICB3aGlsZSAodGFyZ2V0Tm9kZSAmJiAhdGFyZ2V0Tm9kZS5hbmNlc3Rvck9mSEVBRCgpKSB7XG4gICAgICAgIHRhcmdldE5vZGUgPSB0YXJnZXROb2RlLmJlbG93Tm9kZTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZ3JhcGguSEVBRHJlZigpLm5vZGUodGFyZ2V0Tm9kZSA/IHRhcmdldE5vZGUgOiBudWxsKTtcbiAgICAgIHNlbGYuZ3JhcGguY2hlY2tlZE91dFJlZigpLm5vZGUodGFyZ2V0Tm9kZSA/IHRhcmdldE5vZGUgOiBudWxsKTtcbiAgICB9KTtcbn1cblxuR3JhcGhBY3Rpb25zLlJldmVydCA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnBlcmZvcm1Qcm9ncmVzc0Jhci5ydW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgPT0gc2VsZi5ub2RlO1xuICB9KTtcbn1cbmluaGVyaXRzKEdyYXBoQWN0aW9ucy5SZXZlcnQsIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5SZXZlcnQucHJvdG90eXBlLnRleHQgPSAnUmV2ZXJ0JztcbkdyYXBoQWN0aW9ucy5SZXZlcnQucHJvdG90eXBlLnN0eWxlID0gJ3JldmVydCc7XG5HcmFwaEFjdGlvbnMuUmV2ZXJ0LnByb3RvdHlwZS5pY29uID0gJ29jdGljb24gb2N0aWNvbi1oaXN0b3J5JztcbkdyYXBoQWN0aW9ucy5SZXZlcnQucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9yZXZlcnQnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgY29tbWl0OiB0aGlzLm5vZGUuc2hhMSB9KTtcbn1cblxuR3JhcGhBY3Rpb25zLlNxdWFzaCA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnBlcmZvcm1Qcm9ncmVzc0Jhci5ydW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwgJiZcbiAgICAgIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5jdXJyZW50KCkgJiZcbiAgICAgIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5ub2RlKCkgIT0gc2VsZi5ub2RlO1xuICB9KTtcbn1cbmluaGVyaXRzKEdyYXBoQWN0aW9ucy5TcXVhc2gsIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5TcXVhc2gucHJvdG90eXBlLnRleHQgPSAnU3F1YXNoJztcbkdyYXBoQWN0aW9ucy5TcXVhc2gucHJvdG90eXBlLnN0eWxlID0gJ3NxdWFzaCc7XG5HcmFwaEFjdGlvbnMuU3F1YXNoLnByb3RvdHlwZS5pY29uID0gJ29jdGljb24gb2N0aWNvbi1mb2xkJztcbkdyYXBoQWN0aW9ucy5TcXVhc2gucHJvdG90eXBlLmNyZWF0ZUhvdmVyR3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICBsZXQgb250byA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgaWYgKCFvbnRvKSByZXR1cm47XG4gIGlmIChvbnRvIGluc3RhbmNlb2YgUmVmVmlld01vZGVsKSBvbnRvID0gb250by5ub2RlKCk7XG5cbiAgcmV0dXJuIG5ldyBTcXVhc2hWaWV3TW9kZWwodGhpcy5ub2RlLCBvbnRvKTtcbn1cbkdyYXBoQWN0aW9ucy5TcXVhc2gucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbigpIHtcbiAgbGV0IG9udG8gPSB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gIGlmICghb250bykgcmV0dXJuO1xuICBpZiAob250byBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCkgb250byA9IG9udG8ubm9kZSgpO1xuICAvLyByZW1vdmUgbGFzdCBlbGVtZW50IGFzIGl0IHdvdWxkIGJlIGEgY29tbW9uIGFuY2VzdG9yLlxuICBjb25zdCBwYXRoID0gdGhpcy5ub2RlLmdldFBhdGhUb0NvbW1vbkFuY2VzdG9yKG9udG8pLnNsaWNlKDAsIC0xKTtcblxuICBpZiAocGF0aC5sZW5ndGggPiAwKSB7XG4gICAgLy8gc3F1YXNoaW5nIGJyYW5jaGVkIG91dCBsaW5lYWdlXG4gICAgLy8gYyBpcyBjaGVja291dCB3aXRoIHNxdWFzaCB0YXJnZXQgb2YgZSwgcmVzdWx0cyBpbiBzdGFnaW5nIGNoYW5nZXNcbiAgICAvLyBmcm9tIGQgYW5kIGUgb24gdG9wIG9mIGNcbiAgICAvL1xuICAgIC8vIGEgLSBiIC0gKGMpICAgICAgICBhIC0gYiAtIChjKSAtIFtkZV1cbiAgICAvLyAgXFwgICAgICAgICAgIC0+ICAgICBcXFxuICAgIC8vICAgZCAgLSA8ZT4gICAgICAgICAgIGQgLSA8ZT5cbiAgICByZXR1cm4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9zcXVhc2gnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgdGFyZ2V0OiB0aGlzLm5vZGUuc2hhMSB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzcXVhc2hpbmcgYmFja3dhcmQgZnJvbSBzYW1lIGxpbmVhZ2VcbiAgICAvLyBjIGlzIGNoZWNrb3V0IHdpdGggc3F1YXNoIHRhcmdldCBvZiBhLCByZXN1bHRzIGluIGN1cnJlbnQgcmVmIG1vdmVkXG4gICAgLy8gdG8gYSBhbmQgc3RhZ2luZyBjaGFuZ2VzIHdpdGhpbiBiIGFuZCBjIG9uIHRvcCBvZiBhXG4gICAgLy9cbiAgICAvLyA8YT4gLSBiIC0gKGMpICAgICAgIChhKSAtIGIgLSBjXG4gICAgLy8gICAgICAgICAgICAgICAgLT4gICAgIFxcXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBbYmNdXG4gICAgcmV0dXJuIHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5tb3ZlVG8odGhpcy5ub2RlLnNoYTEsIHRydWUpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL3NxdWFzaCcsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCB0YXJnZXQ6IG9udG8uc2hhMSB9KSlcbiAgfVxufVxuIiwiY29uc3Qga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuY29uc3QgY29tcG9uZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LWNvbXBvbmVudHMnKTtcbmNvbnN0IFNlbGVjdGFibGUgPSByZXF1aXJlKCcuL3NlbGVjdGFibGUnKTtcbmNvbnN0IEFuaW1hdGVhYmxlID0gcmVxdWlyZSgnLi9hbmltYXRlYWJsZScpO1xuY29uc3QgcHJvZ3JhbUV2ZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LXByb2dyYW0tZXZlbnRzJyk7XG5jb25zdCBHcmFwaEFjdGlvbnMgPSByZXF1aXJlKCcuL2dpdC1ncmFwaC1hY3Rpb25zJyk7XG5cbmNvbnN0IG1heEJyYW5jaGVzVG9EaXNwbGF5ID0gcGFyc2VJbnQodW5naXQuY29uZmlnLm51bVJlZnNUb1Nob3cgLyA1ICogMyk7ICAvLyAzLzUgb2YgcmVmcyB0byBzaG93IHRvIGJyYW5jaGVzXG5jb25zdCBtYXhUYWdzVG9EaXNwbGF5ID0gdW5naXQuY29uZmlnLm51bVJlZnNUb1Nob3cgLSBtYXhCcmFuY2hlc1RvRGlzcGxheTsgLy8gMi81IG9mIHJlZnMgdG8gc2hvdyB0byB0YWdzXG5cbnZhciBHaXROb2RlVmlld01vZGVsID0gZnVuY3Rpb24oZ3JhcGgsIHNoYTEpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBTZWxlY3RhYmxlLmNhbGwodGhpcywgZ3JhcGgpO1xuICBBbmltYXRlYWJsZS5jYWxsKHRoaXMpO1xuICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gIHRoaXMuc2hhMSA9IHNoYTE7XG4gIHRoaXMuaXNJbml0ZWQgPSBmYWxzZTtcbiAgdGhpcy50aXRsZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnRzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gIHRoaXMuY29tbWl0VGltZSA9IHVuZGVmaW5lZDsgLy8gY29tbWl0IHRpbWUgaW4gc3RyaW5nXG4gIHRoaXMuZGF0ZSA9IHVuZGVmaW5lZDsgICAgICAgLy8gY29tbWl0IHRpbWUgaW4gbnVtZXJpYyBmb3JtYXQgZm9yIHNvcnRcbiAgdGhpcy5jb2xvciA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5pZGVvbG9naWNhbEJyYW5jaCA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5yZW1vdGVUYWdzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gIHRoaXMuYnJhbmNoZXNBbmRMb2NhbFRhZ3MgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcblxuICB0aGlzLnJlZnMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICB2YXIgcnMgPSBzZWxmLmJyYW5jaGVzQW5kTG9jYWxUYWdzKCkuY29uY2F0KHNlbGYucmVtb3RlVGFncygpKTtcbiAgICBycy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmIChiLmN1cnJlbnQoKSkgcmV0dXJuIDE7XG4gICAgICBpZiAoYS5jdXJyZW50KCkpIHJldHVybiAtMTtcbiAgICAgIGlmIChhLmlzTG9jYWwgJiYgIWIuaXNMb2NhbCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKCFhLmlzTG9jYWwgJiYgYi5pc0xvY2FsKSByZXR1cm4gMTtcbiAgICAgIHJldHVybiBhLnJlZk5hbWUgPCBiLnJlZk5hbWUgPyAtMSA6IDE7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJzO1xuICB9KTtcbiAgLy8gVGhlc2UgYXJlIHNwbGl0IHVwIGxpa2UgdGhpcyBiZWNhdXNlIGJyYW5jaGVzIGFuZCBsb2NhbCB0YWdzIGNhbiBiZSBmb3VuZCBpbiB0aGUgZ2l0IGxvZyxcbiAgLy8gd2hlcmVhcyByZW1vdGUgdGFncyBuZWVkcyB0byBiZSBmZXRjaGVkIHdpdGggYW5vdGhlciBjb21tYW5kICh3aGljaCBpcyBtdWNoIHNsb3dlcilcbiAgdGhpcy5icmFuY2hlcyA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICB0aGlzLmJyYW5jaGVzVG9EaXNwbGF5ID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gIHRoaXMudGFncyA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICB0aGlzLnRhZ3NUb0Rpc3BsYXkgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcbiAgdGhpcy5yZWZzLnN1YnNjcmliZSgobmV3VmFsdWUpID0+IHtcbiAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuYnJhbmNoZXMobmV3VmFsdWUuZmlsdGVyKChyKSA9PiByLmlzQnJhbmNoKSk7XG4gICAgICB0aGlzLnRhZ3MobmV3VmFsdWUuZmlsdGVyKChyKSA9PiByLmlzVGFnKSk7XG4gICAgICB0aGlzLnRhZ3NUb0Rpc3BsYXkodGhpcy50YWdzLnNsaWNlKDAsIG1heFRhZ3NUb0Rpc3BsYXkpKTtcbiAgICAgIHRoaXMuYnJhbmNoZXNUb0Rpc3BsYXkodGhpcy5icmFuY2hlcy5zbGljZSgwLCB1bmdpdC5jb25maWcubnVtUmVmc1RvU2hvdyAtIHRoaXMudGFnc1RvRGlzcGxheSgpLmxlbmd0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJyYW5jaGVzLnJlbW92ZUFsbCgpO1xuICAgICAgdGhpcy50YWdzLnJlbW92ZUFsbCgpO1xuICAgICAgdGhpcy5icmFuY2hlc1RvRGlzcGxheS5yZW1vdmVBbGwoKTtcbiAgICAgIHRoaXMudGFnc1RvRGlzcGxheS5yZW1vdmVBbGwoKTtcbiAgICB9XG4gIH0pO1xuICB0aGlzLmFuY2VzdG9yT2ZIRUFEID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMubm9kZUlzTW91c2Vob3ZlciA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmNvbW1pdENvbnRhaW5lclZpc2libGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5hbmNlc3Rvck9mSEVBRCgpIHx8IHNlbGYubm9kZUlzTW91c2Vob3ZlcigpIHx8IHNlbGYuc2VsZWN0ZWQoKTtcbiAgfSk7XG4gIHRoaXMuaGlnaGxpZ2h0ZWQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5ub2RlSXNNb3VzZWhvdmVyKCkgfHwgc2VsZi5zZWxlY3RlZCgpO1xuICB9KTtcbiAgdGhpcy5zZWxlY3RlZC5zdWJzY3JpYmUoZnVuY3Rpb24oKSB7XG4gICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAnZ3JhcGgtcmVuZGVyJyB9KTtcbiAgfSk7XG4gIHRoaXMuc2hvd05ld1JlZkFjdGlvbiA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgfSk7XG4gIHRoaXMubmV3QnJhbmNoTmFtZSA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5uZXdCcmFuY2hOYW1lSGFzRm9jdXMgPSBrby5vYnNlcnZhYmxlKHRydWUpO1xuICB0aGlzLmJyYW5jaGluZ0Zvcm1WaXNpYmxlID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMubmV3QnJhbmNoTmFtZUhhc0ZvY3VzLnN1YnNjcmliZShmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgIGlmICghbmV3VmFsdWUpIHtcbiAgICAgIC8vIFNtYWxsIHRpbWVvdXQgYmVjYXVzZSBpbiBmZiB0aGUgZm9ybSBpcyBoaWRkZW4gYmVmb3JlIHRoZSBzdWJtaXQgY2xpY2sgZXZlbnQgaXMgcmVnaXN0ZXJlZCBvdGhlcndpc2VcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuYnJhbmNoaW5nRm9ybVZpc2libGUoZmFsc2UpO1xuICAgICAgfSwgMjAwKTtcbiAgICB9XG4gIH0pO1xuICB0aGlzLmNhbkNyZWF0ZVJlZiA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLm5ld0JyYW5jaE5hbWUoKSAmJiBzZWxmLm5ld0JyYW5jaE5hbWUoKS50cmltKCkgJiYgc2VsZi5uZXdCcmFuY2hOYW1lKCkuaW5kZXhPZignICcpID09IC0xO1xuICB9KTtcbiAgdGhpcy5icmFuY2hPcmRlciA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5hYm92ZU5vZGUgPSB1bmRlZmluZWQ7XG4gIHRoaXMuYmVsb3dOb2RlID0gdW5kZWZpbmVkO1xuICB0aGlzLnJlZlNlYXJjaEZvcm1WaXNpYmxlID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMuY29tbWl0Q29tcG9uZW50ID0gY29tcG9uZW50cy5jcmVhdGUoJ2NvbW1pdCcsIHRoaXMpO1xuICB0aGlzLnIgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuY3ggPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuY3kgPSBrby5vYnNlcnZhYmxlKCk7XG5cbiAgdGhpcy5kcm9wYXJlYUdyYXBoQWN0aW9ucyA9IFtcbiAgICBuZXcgR3JhcGhBY3Rpb25zLk1vdmUodGhpcy5ncmFwaCwgdGhpcyksXG4gICAgbmV3IEdyYXBoQWN0aW9ucy5SZWJhc2UodGhpcy5ncmFwaCwgdGhpcyksXG4gICAgbmV3IEdyYXBoQWN0aW9ucy5NZXJnZSh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICBuZXcgR3JhcGhBY3Rpb25zLlB1c2godGhpcy5ncmFwaCwgdGhpcyksXG4gICAgbmV3IEdyYXBoQWN0aW9ucy5SZXNldCh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICBuZXcgR3JhcGhBY3Rpb25zLkNoZWNrb3V0KHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuRGVsZXRlKHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuQ2hlcnJ5UGljayh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICBuZXcgR3JhcGhBY3Rpb25zLlVuY29tbWl0KHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuUmV2ZXJ0KHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuU3F1YXNoKHRoaXMuZ3JhcGgsIHRoaXMpXG4gIF07XG59XG5tb2R1bGUuZXhwb3J0cyA9IEdpdE5vZGVWaWV3TW9kZWw7XG5cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLmdldEdyYXBoQXR0ciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW3RoaXMuY3goKSwgdGhpcy5jeSgpXTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnNldEdyYXBoQXR0ciA9IGZ1bmN0aW9uKHZhbCkge1xuICB0aGlzLmVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoJ3gnLCB2YWxbMF0gLSAzMCk7XG4gIHRoaXMuZWxlbWVudCgpLnNldEF0dHJpYnV0ZSgneScsIHZhbFsxXSAtIDMwKTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlZlNlYXJjaEZvcm1WaXNpYmxlKGZhbHNlKTtcbiAgaWYgKCF0aGlzLmlzSW5pdGVkKSByZXR1cm47XG4gIGlmICh0aGlzLmFuY2VzdG9yT2ZIRUFEKCkpIHtcbiAgICB0aGlzLnIoMzApO1xuICAgIHRoaXMuY3goNjEwKTtcblxuICAgIGlmICghdGhpcy5hYm92ZU5vZGUpIHtcbiAgICAgIHRoaXMuY3koMTIwKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWJvdmVOb2RlLmFuY2VzdG9yT2ZIRUFEKCkpIHtcbiAgICAgIHRoaXMuY3kodGhpcy5hYm92ZU5vZGUuY3koKSArIDEyMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3kodGhpcy5hYm92ZU5vZGUuY3koKSArIDYwKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yKDE1KTtcbiAgICB0aGlzLmN4KDYxMCArICg5MCAqIHRoaXMuYnJhbmNoT3JkZXIoKSkpO1xuICAgIHRoaXMuY3kodGhpcy5hYm92ZU5vZGUgPyB0aGlzLmFib3ZlTm9kZS5jeSgpICsgNjAgOiAxMjApO1xuICB9XG5cbiAgaWYgKHRoaXMuYWJvdmVOb2RlICYmIHRoaXMuYWJvdmVOb2RlLnNlbGVjdGVkKCkpIHtcbiAgICB0aGlzLmN5KHRoaXMuYWJvdmVOb2RlLmN5KCkgKyB0aGlzLmFib3ZlTm9kZS5jb21taXRDb21wb25lbnQuZWxlbWVudCgpLm9mZnNldEhlaWdodCArIDMwKTtcbiAgfVxuXG4gIHRoaXMuY29sb3IodGhpcy5pZGVvbG9naWNhbEJyYW5jaCgpID8gdGhpcy5pZGVvbG9naWNhbEJyYW5jaCgpLmNvbG9yIDogJyM2NjYnKTtcbiAgdGhpcy5hbmltYXRlKCk7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24obG9nRW50cnkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnRpdGxlID0gbG9nRW50cnkubWVzc2FnZS5zcGxpdCgnXFxuJylbMF07XG4gIHRoaXMucGFyZW50cyhsb2dFbnRyeS5wYXJlbnRzIHx8IFtdKTtcbiAgdGhpcy5jb21taXRUaW1lID0gbG9nRW50cnkuY29tbWl0RGF0ZTtcbiAgdGhpcy5kYXRlID0gRGF0ZS5wYXJzZSh0aGlzLmNvbW1pdFRpbWUpO1xuICB0aGlzLmNvbW1pdENvbXBvbmVudC5zZXREYXRhKGxvZ0VudHJ5KTtcblxuICAobG9nRW50cnkucmVmcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihyZWYpIHtcbiAgICBzZWxmLmdyYXBoLmdldFJlZihyZWYpLm5vZGUoc2VsZik7XG4gIH0pO1xuICB0aGlzLmlzSW5pdGVkID0gdHJ1ZTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnNob3dCcmFuY2hpbmdGb3JtID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYnJhbmNoaW5nRm9ybVZpc2libGUodHJ1ZSk7XG4gIHRoaXMubmV3QnJhbmNoTmFtZUhhc0ZvY3VzKHRydWUpO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuc2hvd1JlZlNlYXJjaEZvcm0gPSBmdW5jdGlvbihvYmosIGV2ZW50KSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICB0aGlzLnJlZlNlYXJjaEZvcm1WaXNpYmxlKHRydWUpO1xuXG4gIGNvbnN0IHRleHRCb3ggPSBldmVudC50YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nLmZpcnN0RWxlbWVudENoaWxkOyAvLyB0aGlzIG1heSBub3QgYmUgdGhlIGJlc3QgaWRlYS4uLlxuICAkKHRleHRCb3gpLmF1dG9jb21wbGV0ZSh7XG4gICAgc291cmNlOiB0aGlzLnJlZnMoKS5maWx0ZXIocmVmID0+ICFyZWYuaXNIRUFEKSxcbiAgICBtaW5MZW5ndGg6IDAsXG4gICAgc2VsZWN0OiBmdW5jdGlvbihldmVudCwgdWkpIHtcbiAgICAgIGNvbnN0IHJlZiA9IHVpLml0ZW07XG4gICAgICBjb25zdCByYXkgPSByZWYuaXNUYWcgPyBzZWxmLnRhZ3NUb0Rpc3BsYXkgOiBzZWxmLmJyYW5jaGVzVG9EaXNwbGF5O1xuXG4gICAgICAvLyBpZiByZWYgaXMgaW4gZGlzcGxheSwgcmVtb3ZlIGl0LCBlbHNlIHJlbW92ZSBsYXN0IGluIGFycmF5LlxuICAgICAgcmF5LnNwbGljZShyYXkuaW5kZXhPZihyZWYpLCAxKTtcbiAgICAgIHJheS51bnNoaWZ0KHJlZik7XG4gICAgICBzZWxmLnJlZlNlYXJjaEZvcm1WaXNpYmxlKGZhbHNlKTtcbiAgICB9LFxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICBub1Jlc3VsdHM6ICcnLFxuICAgICAgcmVzdWx0czogKCkgPT4ge31cbiAgICB9XG4gIH0pLmZvY3VzKGZ1bmN0aW9uKCkge1xuICAgICQodGhpcykuYXV0b2NvbXBsZXRlKCdzZWFyY2gnLCAkKHRoaXMpLnZhbCgpKTtcbiAgfSkuZGF0YShcInVpLWF1dG9jb21wbGV0ZVwiKS5fcmVuZGVySXRlbSA9IGZ1bmN0aW9uICh1bCwgaXRlbSkge1xuICAgIHJldHVybiAkKFwiPGxpPjwvbGk+XCIpXG4gICAgICAuZGF0YShcIml0ZW0uYXV0b2NvbXBsZXRlXCIsIGl0ZW0pXG4gICAgICAuYXBwZW5kKGA8YT4ke2l0ZW0uZG9tfTwvYT5gKVxuICAgICAgLmFwcGVuZFRvKHVsKTtcbiAgfVxuICAkKHRleHRCb3gpLmF1dG9jb21wbGV0ZSgnc2VhcmNoJywgJycpO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuY3JlYXRlQnJhbmNoID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jYW5DcmVhdGVSZWYoKSkgcmV0dXJuO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjb21tYW5kID0gdW5naXQuY29uZmlnLmF1dG9DaGVja291dE9uQnJhbmNoQ3JlYXRlID8gXCIvY2hlY2tvdXRcIiA6IFwiL2JyYW5jaGVzXCI7XG5cbiAgdGhpcy5ncmFwaC5zZXJ2ZXIucG9zdFByb21pc2UoY29tbWFuZCwgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksIG5hbWU6IHRoaXMubmV3QnJhbmNoTmFtZSgpLCBzaGExOiB0aGlzLnNoYTEgfSlcbiAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZ3JhcGguZ2V0UmVmKCdyZWZzL2hlYWRzLycgKyBzZWxmLm5ld0JyYW5jaE5hbWUoKSkubm9kZShzZWxmKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5icmFuY2hpbmdGb3JtVmlzaWJsZShmYWxzZSk7XG4gICAgICBzZWxmLm5ld0JyYW5jaE5hbWUoJycpO1xuICAgICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAnYnJhbmNoLXVwZGF0ZWQnIH0pO1xuICAgIH0pO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuY3JlYXRlVGFnID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jYW5DcmVhdGVSZWYoKSkgcmV0dXJuO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuZ3JhcGguc2VydmVyLnBvc3RQcm9taXNlKCcvdGFncycsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCBuYW1lOiB0aGlzLm5ld0JyYW5jaE5hbWUoKSwgc2hhMTogdGhpcy5zaGExIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV3UmVmID0gc2VsZi5ncmFwaC5nZXRSZWYoJ3RhZzogcmVmcy90YWdzLycgKyBzZWxmLm5ld0JyYW5jaE5hbWUoKSk7XG4gICAgICBuZXdSZWYubm9kZShzZWxmKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5icmFuY2hpbmdGb3JtVmlzaWJsZShmYWxzZSk7XG4gICAgICBzZWxmLm5ld0JyYW5jaE5hbWUoJycpO1xuICAgIH0pO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUudG9nZ2xlU2VsZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYmVmb3JlVGhpc0NSID0gdGhpcy5jb21taXRDb21wb25lbnQuZWxlbWVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgYmVmb3JlQmVsb3dDUiA9IG51bGw7XG4gIGlmICh0aGlzLmJlbG93Tm9kZSkge1xuICAgIGJlZm9yZUJlbG93Q1IgPSB0aGlzLmJlbG93Tm9kZS5jb21taXRDb21wb25lbnQuZWxlbWVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG5cbiAgdmFyIHByZXZTZWxlY3RlZCAgPSB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gIGlmICghKHByZXZTZWxlY3RlZCBpbnN0YW5jZW9mIEdpdE5vZGVWaWV3TW9kZWwpKSBwcmV2U2VsZWN0ZWQgPSBudWxsO1xuICB2YXIgcHJldlNlbGVjdGVkQ1IgPSBwcmV2U2VsZWN0ZWQgPyBwcmV2U2VsZWN0ZWQuY29tbWl0Q29tcG9uZW50LmVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IG51bGw7XG4gIHRoaXMuc2VsZWN0ZWQoIXRoaXMuc2VsZWN0ZWQoKSk7XG5cbiAgLy8gSWYgd2UgYXJlIGRlc2VsZWN0aW5nXG4gIGlmICghdGhpcy5zZWxlY3RlZCgpKSB7XG4gICAgaWYgKGJlZm9yZVRoaXNDUi50b3AgPCAwICYmIGJlZm9yZUJlbG93Q1IpIHtcbiAgICAgIHZhciBhZnRlckJlbG93Q1IgPSB0aGlzLmJlbG93Tm9kZS5jb21taXRDb21wb25lbnQuZWxlbWVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgLy8gSWYgdGhlIG5leHQgbm9kZSBpcyBzaG93aW5nLCB0cnkgdG8ga2VlcCBpdCBpbiB0aGUgc2NyZWVuIChubyBqdW1waW5nKVxuICAgICAgaWYgKGJlZm9yZUJlbG93Q1IudG9wIDwgd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxCeSgwLCBhZnRlckJlbG93Q1IudG9wIC0gYmVmb3JlQmVsb3dDUi50b3ApO1xuICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgdHJ5IHRvIGJyaW5nIHRoZW0gdG8gdGhlIG1pZGRsZSBvZiB0aGUgc2NyZWVuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsQnkoMCwgYWZ0ZXJCZWxvd0NSLnRvcCAtIHdpbmRvdy5pbm5lckhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH1cbiAgLy8gSWYgd2UgYXJlIHNlbGVjdGluZ1xuICB9IGVsc2Uge1xuICAgIHZhciBhZnRlclRoaXNDUiA9IHRoaXMuY29tbWl0Q29tcG9uZW50LmVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoKHByZXZTZWxlY3RlZENSICYmIChwcmV2U2VsZWN0ZWRDUi50b3AgPCAwIHx8IHByZXZTZWxlY3RlZENSLnRvcCA+IHdpbmRvdy5pbm5lckhlaWdodCkpICYmXG4gICAgICBhZnRlclRoaXNDUi50b3AgIT0gYmVmb3JlVGhpc0NSLnRvcCkge1xuICAgICAgd2luZG93LnNjcm9sbEJ5KDAsIC0oYmVmb3JlVGhpc0NSLnRvcCAtIGFmdGVyVGhpc0NSLnRvcCkpO1xuICAgICAgY29uc29sZS5sb2coJ0ZpeCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5yZW1vdmVSZWYgPSBmdW5jdGlvbihyZWYpIHtcbiAgaWYgKHJlZi5pc1JlbW90ZVRhZykge1xuICAgIHRoaXMucmVtb3RlVGFncy5yZW1vdmUocmVmKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmJyYW5jaGVzQW5kTG9jYWxUYWdzLnJlbW92ZShyZWYpO1xuICB9XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5wdXNoUmVmID0gZnVuY3Rpb24ocmVmKSB7XG4gIGlmIChyZWYuaXNSZW1vdGVUYWcgJiYgdGhpcy5yZW1vdGVUYWdzLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICB0aGlzLnJlbW90ZVRhZ3MucHVzaChyZWYpO1xuICB9IGVsc2UgaWYodGhpcy5icmFuY2hlc0FuZExvY2FsVGFncy5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgdGhpcy5icmFuY2hlc0FuZExvY2FsVGFncy5wdXNoKHJlZik7XG4gIH1cbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLmdldFBhdGhUb0NvbW1vbkFuY2VzdG9yID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgcGF0aCA9IFtdO1xuICB2YXIgdGhpc05vZGUgPSB0aGlzO1xuICB3aGlsZSAodGhpc05vZGUgJiYgIW5vZGUuaXNBbmNlc3Rvcih0aGlzTm9kZSkpIHtcbiAgICBwYXRoLnB1c2godGhpc05vZGUpO1xuICAgIHRoaXNOb2RlID0gdGhpcy5ncmFwaC5ub2Rlc0J5SWRbdGhpc05vZGUucGFyZW50cygpWzBdXTtcbiAgfVxuICBpZiAodGhpc05vZGUpIHBhdGgucHVzaCh0aGlzTm9kZSk7XG4gIHJldHVybiBwYXRoO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuaXNBbmNlc3RvciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gdGhpcykgcmV0dXJuIHRydWU7XG4gIGZvciAodmFyIHYgaW4gdGhpcy5wYXJlbnRzKCkpIHtcbiAgICB2YXIgbiA9IHRoaXMuZ3JhcGgubm9kZXNCeUlkW3RoaXMucGFyZW50cygpW3ZdXTtcbiAgICBpZiAobiAmJiBuLmlzQW5jZXN0b3Iobm9kZSkpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLmdldFJpZ2h0VG9MZWZ0U3RyaWtlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnTSAnICsgKHRoaXMuY3goKSAtIDMwKSArICcgJyArICh0aGlzLmN5KCkgLSAzMCkgKyAnIEwgJyArICh0aGlzLmN4KCkgKyAzMCkgKyAnICcgKyAodGhpcy5jeSgpICsgMzApO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0TGVmdFRvUmlnaHRTdHJpa2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdNICcgKyAodGhpcy5jeCgpICsgMzApICsgJyAnICsgKHRoaXMuY3koKSAtIDMwKSArICcgTCAnICsgKHRoaXMuY3goKSAtIDMwKSArICcgJyArICh0aGlzLmN5KCkgKyAzMCk7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5ub2RlTW91c2VvdmVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubm9kZUlzTW91c2Vob3Zlcih0cnVlKTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLm5vZGVNb3VzZW91dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm5vZGVJc01vdXNlaG92ZXIoZmFsc2UpO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuaXNWaWV3YWJsZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaC5ub2RlcygpLmluZGV4T2YodGhpcykgPiAtMTtcbn1cbiIsInZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG52YXIgbWQ1ID0gcmVxdWlyZSgnYmx1ZWltcC1tZDUnKTtcbnZhciBTZWxlY3RhYmxlID0gcmVxdWlyZSgnLi9zZWxlY3RhYmxlJyk7XG52YXIgcHJvZ3JhbUV2ZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LXByb2dyYW0tZXZlbnRzJyk7XG52YXIgY29tcG9uZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LWNvbXBvbmVudHMnKTtcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcblxudmFyIFJlZlZpZXdNb2RlbCA9IGZ1bmN0aW9uKGZ1bGxSZWZOYW1lLCBncmFwaCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIFNlbGVjdGFibGUuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgdGhpcy5uYW1lID0gZnVsbFJlZk5hbWU7XG4gIHRoaXMubm9kZSA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5sb2NhbFJlZk5hbWUgPSB0aGlzLm5hbWU7IC8vIG9yaWdpbi9tYXN0ZXIgb3IgbWFzdGVyXG4gIHRoaXMucmVmTmFtZSA9IHRoaXMubmFtZTsgLy8gbWFzdGVyXG4gIHRoaXMuaXNSZW1vdGVUYWcgPSB0aGlzLm5hbWUuaW5kZXhPZigncmVtb3RlLXRhZzogJykgPT0gMDtcbiAgdGhpcy5pc0xvY2FsVGFnID0gdGhpcy5uYW1lLmluZGV4T2YoJ3RhZzogJykgPT0gMDtcbiAgdGhpcy5pc1RhZyA9IHRoaXMuaXNMb2NhbFRhZyB8fCB0aGlzLmlzUmVtb3RlVGFnO1xuICB2YXIgaXNSZW1vdGVCcmFuY2hPckhFQUQgPSB0aGlzLm5hbWUuaW5kZXhPZigncmVmcy9yZW1vdGVzLycpID09IDA7XG4gIHRoaXMuaXNMb2NhbEhFQUQgPSB0aGlzLm5hbWUgPT0gJ0hFQUQnO1xuICB0aGlzLmlzUmVtb3RlSEVBRCA9IHRoaXMubmFtZS5pbmRleE9mKCcvSEVBRCcpICE9IC0xO1xuICB0aGlzLmlzTG9jYWxCcmFuY2ggPSB0aGlzLm5hbWUuaW5kZXhPZigncmVmcy9oZWFkcy8nKSA9PSAwO1xuICB0aGlzLmlzUmVtb3RlQnJhbmNoID0gaXNSZW1vdGVCcmFuY2hPckhFQUQgJiYgIXRoaXMuaXNSZW1vdGVIRUFEO1xuICB0aGlzLmlzU3Rhc2ggPSB0aGlzLm5hbWUuaW5kZXhPZigncmVmcy9zdGFzaCcpID09IDA7XG4gIHRoaXMuaXNIRUFEID0gdGhpcy5pc0xvY2FsSEVBRCB8fCB0aGlzLmlzUmVtb3RlSEVBRDtcbiAgdGhpcy5pc0JyYW5jaCA9IHRoaXMuaXNMb2NhbEJyYW5jaCB8fCB0aGlzLmlzUmVtb3RlQnJhbmNoO1xuICB0aGlzLmlzUmVtb3RlID0gaXNSZW1vdGVCcmFuY2hPckhFQUQgfHwgdGhpcy5pc1JlbW90ZVRhZztcbiAgdGhpcy5pc0xvY2FsID0gdGhpcy5pc0xvY2FsQnJhbmNoIHx8IHRoaXMuaXNMb2NhbFRhZztcbiAgaWYgKHRoaXMuaXNMb2NhbEJyYW5jaCkge1xuICAgIHRoaXMubG9jYWxSZWZOYW1lID0gdGhpcy5uYW1lLnNsaWNlKCdyZWZzL2hlYWRzLycubGVuZ3RoKTtcbiAgICB0aGlzLnJlZk5hbWUgPSB0aGlzLmxvY2FsUmVmTmFtZTtcbiAgfVxuICBpZiAodGhpcy5pc1JlbW90ZUJyYW5jaCkge1xuICAgIHRoaXMubG9jYWxSZWZOYW1lID0gdGhpcy5uYW1lLnNsaWNlKCdyZWZzL3JlbW90ZXMvJy5sZW5ndGgpO1xuICB9XG4gIGlmICh0aGlzLmlzTG9jYWxUYWcpIHtcbiAgICB0aGlzLmxvY2FsUmVmTmFtZSA9IHRoaXMubmFtZS5zbGljZSgndGFnOiByZWZzL3RhZ3MvJy5sZW5ndGgpO1xuICAgIHRoaXMucmVmTmFtZSA9IHRoaXMubG9jYWxSZWZOYW1lO1xuICB9XG4gIGlmICh0aGlzLmlzUmVtb3RlVGFnKSB7XG4gICAgdGhpcy5sb2NhbFJlZk5hbWUgPSB0aGlzLm5hbWUuc2xpY2UoJ3JlbW90ZS10YWc6ICcubGVuZ3RoKTtcbiAgfVxuICBjb25zdCBzcGxpdGVkTmFtZSA9IHRoaXMubG9jYWxSZWZOYW1lLnNwbGl0KCcvJylcbiAgaWYgKHRoaXMuaXNSZW1vdGUpIHtcbiAgICAvLyBnZXQgcmlkIG9mIHRoZSBvcmlnaW4vIHBhcnQgb2Ygb3JpZ2luL2JyYW5jaG5hbWVcbiAgICB0aGlzLnJlbW90ZSA9IHNwbGl0ZWROYW1lWzBdO1xuICAgIHRoaXMucmVmTmFtZSA9IHNwbGl0ZWROYW1lLnNsaWNlKDEpLmpvaW4oJy8nKTtcbiAgfVxuICB0aGlzLnNob3cgPSB0cnVlO1xuICB0aGlzLnNlcnZlciA9IHRoaXMuZ3JhcGguc2VydmVyO1xuICB0aGlzLmlzRHJhZ2dpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgdGhpcy5jdXJyZW50ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuaXNMb2NhbEJyYW5jaCAmJiBzZWxmLmdyYXBoLmNoZWNrZWRPdXRCcmFuY2goKSA9PSBzZWxmLnJlZk5hbWU7XG4gIH0pO1xuICB0aGlzLmNvbG9yID0gdGhpcy5fY29sb3JGcm9tSGFzaE9mU3RyaW5nKHRoaXMubmFtZSk7XG5cbiAgdGhpcy5ub2RlLnN1YnNjcmliZShmdW5jdGlvbihvbGROb2RlKSB7XG4gICAgaWYgKG9sZE5vZGUpIG9sZE5vZGUucmVtb3ZlUmVmKHNlbGYpO1xuICB9LCBudWxsLCBcImJlZm9yZUNoYW5nZVwiKTtcbiAgdGhpcy5ub2RlLnN1YnNjcmliZShmdW5jdGlvbihuZXdOb2RlKSB7XG4gICAgaWYgKG5ld05vZGUpIG5ld05vZGUucHVzaFJlZihzZWxmKTtcbiAgfSk7XG5cbiAgLy8gVGhpcyBvcHRpbWl6YXRpb24gaXMgZm9yIGF1dG9jb21wbGV0ZSBkaXNwbGF5XG4gIHRoaXMudmFsdWUgPSBzcGxpdGVkTmFtZVtzcGxpdGVkTmFtZS5sZW5ndGggLSAxXVxuICB0aGlzLmxhYmVsID0gdGhpcy5sb2NhbFJlZk5hbWVcbiAgdGhpcy5kb20gPSBgJHt0aGlzLmxvY2FsUmVmTmFtZX08c3BhbiBjbGFzcz0nb2N0aWNvbiAke3RoaXMuaXNUYWcgPyAnb2N0aWNvbi10YWcnIDogJ29jdGljb24tZ2l0LWJyYW5jaCd9Jz48L3NwYW4+YFxufTtcbm1vZHVsZS5leHBvcnRzID0gUmVmVmlld01vZGVsO1xuXG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLl9jb2xvckZyb21IYXNoT2ZTdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgcmV0dXJuICcjJyArIG1kNShzdHJpbmcpLnRvU3RyaW5nKCkuc2xpY2UoMCwgNik7XG59XG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLmRyYWdTdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KHRoaXMpO1xuICB0aGlzLmlzRHJhZ2dpbmcodHJ1ZSk7XG4gIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50KSBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbn1cblJlZlZpZXdNb2RlbC5wcm90b3R5cGUuZHJhZ0VuZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KG51bGwpO1xuICB0aGlzLmlzRHJhZ2dpbmcoZmFsc2UpO1xufVxuUmVmVmlld01vZGVsLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbih0YXJnZXQsIHJld2luZFdhcm5PdmVycmlkZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9taXNlO1xuICBpZiAodGhpcy5pc0xvY2FsKSB7XG4gICAgdmFyIHRvTm9kZSA9IHRoaXMuZ3JhcGgubm9kZXNCeUlkW3RhcmdldF07XG4gICAgdmFyIGFyZ3MgPSB7IHBhdGg6IHNlbGYuZ3JhcGgucmVwb1BhdGgoKSwgbmFtZTogc2VsZi5yZWZOYW1lLCBzaGExOiB0YXJnZXQsIGZvcmNlOiB0cnVlLCB0bzogdGFyZ2V0LCBtb2RlOiAnaGFyZCcgfTtcbiAgICB2YXIgb3BlcmF0aW9uO1xuICAgIGlmICh0aGlzLmN1cnJlbnQoKSkge1xuICAgICAgb3BlcmF0aW9uID0gJy9yZXNldCc7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVGFnKSB7XG4gICAgICBvcGVyYXRpb24gPSAnL3RhZ3MnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcGVyYXRpb24gPSAnL2JyYW5jaGVzJztcbiAgICB9XG5cbiAgICBpZiAoIXJld2luZFdhcm5PdmVycmlkZSAmJiB0aGlzLm5vZGUoKS5kYXRlID4gdG9Ob2RlLmRhdGUpIHtcbiAgICAgIHByb21pc2UgPSBjb21wb25lbnRzLmNyZWF0ZSgneWVzbm9kaWFsb2cnLCB7IHRpdGxlOiAnQXJlIHlvdSBzdXJlPycsIGRldGFpbHM6ICdUaGlzIG9wZXJhdGlvbiBwb3RlbnRpYWxseSBnb2luZyBiYWNrIGluIGhpc3RvcnkuJ30pXG4gICAgICAgIC5zaG93KClcbiAgICAgICAgLmNsb3NlVGhlbihmdW5jdGlvbihkaWFnKSB7XG4gICAgICAgICAgaWYgKGRpYWcucmVzdWx0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnNlcnZlci5wb3N0UHJvbWlzZShvcGVyYXRpb24sIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2xvc2VQcm9taXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlID0gc2VsZi5zZXJ2ZXIucG9zdFByb21pc2Uob3BlcmF0aW9uLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHB1c2hSZXEgPSB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgcmVtb3RlOiB0aGlzLnJlbW90ZSwgcmVmU3BlYzogdGFyZ2V0LCByZW1vdGVCcmFuY2g6IHRoaXMucmVmTmFtZSB9O1xuICAgIHByb21pc2UgPSB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL3B1c2gnLCBwdXNoUmVxKVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZXJyLmVycm9yQ29kZSA9PSAnbm9uLWZhc3QtZm9yd2FyZCcpIHtcbiAgICAgICAgICByZXR1cm4gY29tcG9uZW50cy5jcmVhdGUoJ3llc25vZGlhbG9nJywgeyB0aXRsZTogJ0ZvcmNlIHB1c2g/JywgZGV0YWlsczogJ1RoZSByZW1vdGUgYnJhbmNoIGNhblxcJ3QgYmUgZmFzdC1mb3J3YXJkZWQuJyB9KVxuICAgICAgICAgICAgLnNob3coKVxuICAgICAgICAgICAgLmNsb3NlVGhlbihmdW5jdGlvbihkaWFnKSB7XG4gICAgICAgICAgICAgIGlmICghZGlhZy5yZXN1bHQoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICBwdXNoUmVxLmZvcmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2VydmVyLnBvc3RQcm9taXNlKCcvcHVzaCcsIHB1c2hSZXEpO1xuICAgICAgICAgICAgfSkuY2xvc2VQcm9taXNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlXG4gICAgLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICBpZiAoIXJlcykgcmV0dXJuO1xuICAgICAgdmFyIHRhcmdldE5vZGUgPSBzZWxmLmdyYXBoLmdldE5vZGUodGFyZ2V0KTtcbiAgICAgIGlmIChzZWxmLmdyYXBoLmNoZWNrZWRPdXRCcmFuY2goKSA9PSBzZWxmLnJlZk5hbWUpIHtcbiAgICAgICAgc2VsZi5ncmFwaC5IRUFEcmVmKCkubm9kZSh0YXJnZXROb2RlKTtcbiAgICAgIH1cbiAgICAgIHNlbGYubm9kZSh0YXJnZXROb2RlKTtcbiAgICB9KTtcbn1cblxuUmVmVmlld01vZGVsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdXJsID0gdGhpcy5pc1RhZyA/ICcvdGFncycgOiAnL2JyYW5jaGVzJztcbiAgaWYgKHRoaXMuaXNSZW1vdGUpIHVybCA9ICcvcmVtb3RlJyArIHVybDtcblxuICByZXR1cm4gdGhpcy5zZXJ2ZXIuZGVsUHJvbWlzZSh1cmwsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCByZW1vdGU6IHRoaXMuaXNSZW1vdGUgPyB0aGlzLnJlbW90ZSA6IG51bGwsIG5hbWU6IHRoaXMucmVmTmFtZSB9KVxuICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5ub2RlKCkucmVtb3ZlUmVmKHNlbGYpO1xuICAgICAgc2VsZi5ncmFwaC5yZWZzQnlSZWZOYW1lW3NlbGYubmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgIGlmICh1cmwgPT0gJy9yZW1vdGUvdGFncycpIHtcbiAgICAgICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAncmVxdWVzdC1mZXRjaC10YWdzJyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2dyYW1FdmVudHMuZGlzcGF0Y2goeyBldmVudDogJ2JyYW5jaC11cGRhdGVkJyB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmdyYXBoLmxvYWROb2Rlc0Zyb21BcGkoKTtcbiAgICB9KTtcbn1cblxuUmVmVmlld01vZGVsLnByb3RvdHlwZS5nZXRMb2NhbFJlZiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaC5nZXRSZWYodGhpcy5nZXRMb2NhbFJlZkZ1bGxOYW1lKCksIGZhbHNlKTtcbn1cblJlZlZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0TG9jYWxSZWZGdWxsTmFtZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pc1JlbW90ZUJyYW5jaCkgcmV0dXJuICdyZWZzL2hlYWRzLycgKyB0aGlzLnJlZk5hbWU7XG4gIGlmICh0aGlzLmlzUmVtb3RlVGFnKSByZXR1cm4gJ3RhZzogJyArIHRoaXMucmVmTmFtZTtcbiAgcmV0dXJuIG51bGw7XG59XG5cblJlZlZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0UmVtb3RlUmVmID0gZnVuY3Rpb24ocmVtb3RlKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoLmdldFJlZih0aGlzLmdldFJlbW90ZVJlZkZ1bGxOYW1lKHJlbW90ZSksIGZhbHNlKTtcbn1cblxuUmVmVmlld01vZGVsLnByb3RvdHlwZS5nZXRSZW1vdGVSZWZGdWxsTmFtZSA9IGZ1bmN0aW9uKHJlbW90ZSkge1xuICBpZiAodGhpcy5pc0xvY2FsQnJhbmNoKSByZXR1cm4gJ3JlZnMvcmVtb3Rlcy8nICsgcmVtb3RlICsgJy8nICsgdGhpcy5yZWZOYW1lO1xuICBpZiAodGhpcy5pc0xvY2FsVGFnKSByZXR1cm4gJ3JlbW90ZS10YWc6ICcgKyByZW1vdGUgKyAnLycgKyB0aGlzLnJlZk5hbWU7XG4gIHJldHVybiBudWxsO1xufVxuXG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLmNhbkJlUHVzaGVkID0gZnVuY3Rpb24ocmVtb3RlKSB7XG4gIGlmICghdGhpcy5pc0xvY2FsKSByZXR1cm4gZmFsc2U7XG4gIHZhciByZW1vdGVSZWYgPSB0aGlzLmdldFJlbW90ZVJlZihyZW1vdGUpO1xuICBpZiAoIXJlbW90ZVJlZikgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0aGlzLm5vZGUoKSAhPSByZW1vdGVSZWYubm9kZSgpO1xufVxuXG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLmNyZWF0ZVJlbW90ZVJlZiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL3B1c2gnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgcmVtb3RlOiB0aGlzLmdyYXBoLmN1cnJlbnRSZW1vdGUoKSxcbiAgICByZWZTcGVjOiB0aGlzLnJlZk5hbWUsIHJlbW90ZUJyYW5jaDogdGhpcy5yZWZOYW1lIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV3UmVmID0gc2VsZi5ncmFwaC5nZXRSZWYoXCJyZWZzL3JlbW90ZXMvXCIgKyBzZWxmLmdyYXBoLmN1cnJlbnRSZW1vdGUoKSArIFwiL1wiICsgc2VsZi5yZWZOYW1lKTtcbiAgICAgIG5ld1JlZi5ub2RlKHNlbGYubm9kZSgpKTtcbiAgICB9KTtcbn1cbiIsInZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG52YXIgY29tcG9uZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LWNvbXBvbmVudHMnKTtcbnZhciBHaXROb2RlVmlld01vZGVsID0gcmVxdWlyZSgnLi9naXQtbm9kZScpO1xudmFyIEdpdFJlZlZpZXdNb2RlbCA9IHJlcXVpcmUoJy4vZ2l0LXJlZicpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcbnZhciBFZGdlVmlld01vZGVsID0gcmVxdWlyZSgnLi9lZGdlJyk7XG52YXIgbnVtYmVyT2ZOb2Rlc1BlckxvYWQgPSB1bmdpdC5jb25maWcubnVtYmVyT2ZOb2Rlc1BlckxvYWQ7XG5cbmNvbXBvbmVudHMucmVnaXN0ZXIoJ2dyYXBoJywgZnVuY3Rpb24oYXJncykge1xuICByZXR1cm4gbmV3IEdyYXBoVmlld01vZGVsKGFyZ3Muc2VydmVyLCBhcmdzLnJlcG9QYXRoKTtcbn0pO1xuXG5mdW5jdGlvbiBHcmFwaFZpZXdNb2RlbChzZXJ2ZXIsIHJlcG9QYXRoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZXBvUGF0aCA9IHJlcG9QYXRoO1xuICB0aGlzLmxpbWl0ID0ga28ub2JzZXJ2YWJsZShudW1iZXJPZk5vZGVzUGVyTG9hZCk7XG4gIHRoaXMuc2tpcCA9IGtvLm9ic2VydmFibGUoMCk7XG4gIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICB0aGlzLmN1cnJlbnRSZW1vdGUgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMubm9kZXNMb2FkZXIgPSBjb21wb25lbnRzLmNyZWF0ZSgncHJvZ3Jlc3NCYXInLCB7XG4gICAgcHJlZGljdGlvbk1lbW9yeUtleTogJ2dpdGdyYXBoLScgKyBzZWxmLnJlcG9QYXRoKCksXG4gICAgZmFsbGJhY2tQcmVkaWN0ZWRUaW1lTXM6IDEwMDAsXG4gICAgdGVtcG9yYXJ5OiB0cnVlXG4gIH0pO1xuICB0aGlzLm5vZGVzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gIHRoaXMuZWRnZXMgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcbiAgdGhpcy5yZWZzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gIHRoaXMubm9kZXNCeUlkID0ge307XG4gIHRoaXMucmVmc0J5UmVmTmFtZSA9IHt9O1xuICB0aGlzLmNoZWNrZWRPdXRCcmFuY2ggPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuY2hlY2tlZE91dFJlZiA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLmNoZWNrZWRPdXRCcmFuY2goKSA/IHNlbGYuZ2V0UmVmKCdyZWZzL2hlYWRzLycgKyBzZWxmLmNoZWNrZWRPdXRCcmFuY2goKSkgOiBudWxsO1xuICB9KTtcbiAgdGhpcy5IRUFEcmVmID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLkhFQUQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5IRUFEcmVmKCkgPyBzZWxmLkhFQURyZWYoKS5ub2RlKCkgOiB1bmRlZmluZWQ7XG4gIH0pO1xuICB0aGlzLmNvbW1pdE5vZGVDb2xvciA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLkhFQUQoKSA/IHNlbGYuSEVBRCgpLmNvbG9yKCkgOiAnIzRBNEE0QSc7XG4gIH0pO1xuICB0aGlzLmNvbW1pdE5vZGVFZGdlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFzZWxmLkhFQUQoKSB8fCAhc2VsZi5IRUFEKCkuY3goKSB8fCAhc2VsZi5IRUFEKCkuY3koKSkgcmV0dXJuO1xuICAgIHJldHVybiBcIk0gNjEwIDY4IEwgXCIgKyBzZWxmLkhFQUQoKS5jeCgpICsgXCIgXCIgKyBzZWxmLkhFQUQoKS5jeSgpO1xuICB9KTtcbiAgdGhpcy5zaG93Q29tbWl0Tm9kZSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmN1cnJlbnRBY3Rpb25Db250ZXh0ID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmVkZ2VzQnlJZCA9IHt9O1xuICB0aGlzLnNjcm9sbGVkVG9FbmQgPSBfLmRlYm91bmNlKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYubGltaXQobnVtYmVyT2ZOb2Rlc1BlckxvYWQgKyBzZWxmLmxpbWl0KCkpO1xuICAgIHNlbGYubG9hZE5vZGVzRnJvbUFwaSgpO1xuICB9LCA1MDAsIHRydWUpO1xuICB0aGlzLmxvYWRBaGVhZCA9IF8uZGVib3VuY2UoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuc2tpcCgpIDw9IDApIHJldHVybjtcbiAgICBzZWxmLnNraXAoTWF0aC5tYXgoc2VsZi5za2lwKCkgLSBudW1iZXJPZk5vZGVzUGVyTG9hZCwgMCkpO1xuICAgIHNlbGYubG9hZE5vZGVzRnJvbUFwaSgpO1xuICB9LCA1MDAsIHRydWUpO1xuICB0aGlzLmRpbUNvbW1pdCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmNvbW1pdE9wYWNpdHkgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYuZGltQ29tbWl0KCkgPyAwLjEgOiAxOyB9KTtcbiAgdGhpcy5oZWlnaHN0QnJhbmNoT3JkZXIgPSAwO1xuICB0aGlzLmhvdmVyR3JhcGhBY3Rpb25HcmFwaGljID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmhvdmVyR3JhcGhBY3Rpb25HcmFwaGljLnN1YnNjcmliZShmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5kZXN0cm95KVxuICAgICAgdmFsdWUuZGVzdHJveSgpO1xuICB9LCBudWxsLCAnYmVmb3JlQ2hhbmdlJyk7XG5cbiAgdGhpcy5ob3ZlckdyYXBoQWN0aW9uID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmhvdmVyR3JhcGhBY3Rpb24uc3Vic2NyaWJlKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmNyZWF0ZUhvdmVyR3JhcGhpYykge1xuICAgICAgc2VsZi5ob3ZlckdyYXBoQWN0aW9uR3JhcGhpYyh2YWx1ZS5jcmVhdGVIb3ZlckdyYXBoaWMoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuaG92ZXJHcmFwaEFjdGlvbkdyYXBoaWMobnVsbCk7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLmxvYWROb2Rlc0Zyb21BcGlUaHJvdHRsZWQgPSBfLnRocm90dGxlKHRoaXMubG9hZE5vZGVzRnJvbUFwaS5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgdGhpcy51cGRhdGVCcmFuY2hlc1Rocm90dGxlZCA9IF8udGhyb3R0bGUodGhpcy51cGRhdGVCcmFuY2hlcy5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgdGhpcy5sb2FkTm9kZXNGcm9tQXBpKCk7XG4gIHRoaXMudXBkYXRlQnJhbmNoZXMoKTtcbiAgdGhpcy5ncmFwaFdpZHRoID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmdyYXBoSGVpZ2h0ID0ga28ub2JzZXJ2YWJsZSg4MDApO1xufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUudXBkYXRlTm9kZSA9IGZ1bmN0aW9uKHBhcmVudEVsZW1lbnQpIHtcbiAga28ucmVuZGVyVGVtcGxhdGUoJ2dyYXBoJywgdGhpcywge30sIHBhcmVudEVsZW1lbnQpO1xufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uKHNoYTEsIGxvZ0VudHJ5KSB7XG4gIHZhciBub2RlVmlld01vZGVsID0gdGhpcy5ub2Rlc0J5SWRbc2hhMV07XG4gIGlmICghbm9kZVZpZXdNb2RlbCkgbm9kZVZpZXdNb2RlbCA9IHRoaXMubm9kZXNCeUlkW3NoYTFdID0gbmV3IEdpdE5vZGVWaWV3TW9kZWwodGhpcywgc2hhMSk7XG4gIGlmIChsb2dFbnRyeSkgbm9kZVZpZXdNb2RlbC5zZXREYXRhKGxvZ0VudHJ5KTtcbiAgcmV0dXJuIG5vZGVWaWV3TW9kZWw7XG59XG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0UmVmID0gZnVuY3Rpb24ocmVmLCBjb25zdHJ1Y3RJZlVuYXZhaWxhYmxlKSB7XG4gIGlmIChjb25zdHJ1Y3RJZlVuYXZhaWxhYmxlID09PSB1bmRlZmluZWQpIGNvbnN0cnVjdElmVW5hdmFpbGFibGUgPSB0cnVlO1xuICB2YXIgcmVmVmlld01vZGVsID0gdGhpcy5yZWZzQnlSZWZOYW1lW3JlZl07XG4gIGlmICghcmVmVmlld01vZGVsICYmIGNvbnN0cnVjdElmVW5hdmFpbGFibGUpIHtcbiAgICByZWZWaWV3TW9kZWwgPSB0aGlzLnJlZnNCeVJlZk5hbWVbcmVmXSA9IG5ldyBHaXRSZWZWaWV3TW9kZWwocmVmLCB0aGlzKTtcbiAgICB0aGlzLnJlZnMucHVzaChyZWZWaWV3TW9kZWwpO1xuICAgIGlmIChyZWZWaWV3TW9kZWwubmFtZSA9PT0gJ0hFQUQnKSB7XG4gICAgICB0aGlzLkhFQURyZWYocmVmVmlld01vZGVsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZlZpZXdNb2RlbDtcbn1cblxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLmxvYWROb2Rlc0Zyb21BcGkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbm9kZVNpemUgPSBzZWxmLm5vZGVzKCkubGVuZ3RoO1xuXG4gIHRoaXMubm9kZXNMb2FkZXIuc3RhcnQoKTtcbiAgcmV0dXJuIHRoaXMuc2VydmVyLmdldFByb21pc2UoJy9sb2cnLCB7IHBhdGg6IHRoaXMucmVwb1BhdGgoKSwgbGltaXQ6IHRoaXMubGltaXQoKSwgc2tpcDogdGhpcy5za2lwKCkgfSlcbiAgICAudGhlbihmdW5jdGlvbihsb2cpIHtcbiAgICAgIC8vIHNldCBuZXcgbGltaXQgYW5kIHNraXBcbiAgICAgIHNlbGYubGltaXQocGFyc2VJbnQobG9nLmxpbWl0KSk7XG4gICAgICBzZWxmLnNraXAocGFyc2VJbnQobG9nLnNraXApKTtcbiAgICAgIHJldHVybiBsb2cubm9kZXMgfHwgW107XG4gICAgfSkudGhlbihmdW5jdGlvbihub2Rlcykge1xuICAgICAgLy8gY2hlY2sgZm9yIGRlbGV0ZWQgcmVmcyB0byB1cGRhdGUgdGhlIFVJXG4gICAgICB2YXIgdXBkYXRlZFJlZnMgPSBbXTtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obG9nRW50cnkpIHtcbiAgICAgICAgdXBkYXRlZFJlZnMgPSB1cGRhdGVkUmVmcy5jb25jYXQobG9nRW50cnkucmVmcyk7XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5rZXlzKHNlbGYucmVmc0J5UmVmTmFtZSkuZm9yRWFjaChmdW5jdGlvbihyZWZOYW1lKSB7XG4gICAgICAgIGlmICh1cGRhdGVkUmVmcy5pbmRleE9mKHJlZk5hbWUpIDwgMCkge1xuICAgICAgICAgIHNlbGYucmVmcy5yZW1vdmUoc2VsZi5yZWZzQnlSZWZOYW1lW3JlZk5hbWVdKTtcbiAgICAgICAgICB2YXIgcmVmID0gc2VsZi5yZWZzQnlSZWZOYW1lW3JlZk5hbWVdO1xuICAgICAgICAgIGlmIChyZWYpIHsgcmVmLm5vZGUobnVsbCk7IH1cbiAgICAgICAgICBkZWxldGUgc2VsZi5yZWZzQnlSZWZOYW1lW3JlZk5hbWVdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgIC8vIGNyZWF0ZSBhbmQvb3IgY2FsY3VsYXRlIG5vZGVzXG4gICAgICByZXR1cm4gc2VsZi5jb21wdXRlTm9kZShub2Rlcy5tYXAoZnVuY3Rpb24obG9nRW50cnkpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0Tm9kZShsb2dFbnRyeS5zaGExLCBsb2dFbnRyeSk7XG4gICAgICB9KSk7XG4gICAgfSkudGhlbihmdW5jdGlvbihub2Rlcykge1xuICAgICAgLy8gY3JlYXRlIGVkZ2VzXG4gICAgICB2YXIgZWRnZXMgPSBbXTtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudHMoKS5mb3JFYWNoKGZ1bmN0aW9uKHBhcmVudFNoYTEpIHtcbiAgICAgICAgICBlZGdlcy5wdXNoKHNlbGYuZ2V0RWRnZShub2RlLnNoYTEsIHBhcmVudFNoYTEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGUucmVuZGVyKCk7XG4gICAgICB9KTtcblxuICAgICAgc2VsZi5lZGdlcyhlZGdlcyk7XG4gICAgICBzZWxmLm5vZGVzKG5vZGVzKTtcbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlbGYuZ3JhcGhIZWlnaHQobm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0uY3koKSArIDgwKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZ3JhcGhXaWR0aCgxMDAwICsgKHNlbGYuaGVpZ2hzdEJyYW5jaE9yZGVyICogOTApKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5ub2Rlc0xvYWRlci5zdG9wKCk7XG4gICAgICBpZiAod2luZG93LmlubmVySGVpZ2h0IC0gc2VsZi5ncmFwaEhlaWdodCgpID4gMCAmJiBub2RlU2l6ZSAhPSBzZWxmLm5vZGVzKCkubGVuZ3RoKSB7XG4gICAgICAgIHNlbGYuc2Nyb2xsZWRUb0VuZCgpO1xuICAgICAgfVxuICAgIH0pO1xufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUudHJhdmVyc2VOb2RlTGVmdFBhcmVudHMgPSBmdW5jdGlvbihub2RlLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayhub2RlKTtcbiAgdmFyIHBhcmVudCA9IHRoaXMubm9kZXNCeUlkW25vZGUucGFyZW50cygpWzBdXTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHRoaXMudHJhdmVyc2VOb2RlTGVmdFBhcmVudHMocGFyZW50LCBjYWxsYmFjayk7XG4gIH1cbn1cblxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLmNvbXB1dGVOb2RlID0gZnVuY3Rpb24obm9kZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIG5vZGVzID0gbm9kZXMgfHwgdGhpcy5ub2RlcygpO1xuXG4gIHRoaXMubWFya05vZGVzSWRlb2xvZ2ljYWxCcmFuY2hlcyh0aGlzLnJlZnMoKSwgbm9kZXMsIHRoaXMubm9kZXNCeUlkKTtcblxuICB2YXIgdXBkYXRlVGltZVN0YW1wID0gbW9tZW50KCkudmFsdWVPZigpO1xuICBpZiAodGhpcy5IRUFEKCkpIHtcbiAgICB0aGlzLnRyYXZlcnNlTm9kZUxlZnRQYXJlbnRzKHRoaXMuSEVBRCgpLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLmFuY2VzdG9yT2ZIRUFEVGltZVN0YW1wID0gdXBkYXRlVGltZVN0YW1wO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gRmlsdGVyIG91dCBub2RlcyB3aGljaCBkb2Vzbid0IGhhdmUgYSBicmFuY2ggKHN0YWdpbmcgYW5kIG9ycGhhbmVkIG5vZGVzKVxuICBub2RlcyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmlkZW9sb2dpY2FsQnJhbmNoKCkgJiYgIW5vZGUuaWRlb2xvZ2ljYWxCcmFuY2goKS5pc1N0YXNoKSB8fCBub2RlLmFuY2VzdG9yT2ZIRUFEVGltZVN0YW1wID09IHVwZGF0ZVRpbWVTdGFtcDtcbiAgfSk7XG5cbiAgdmFyIGJyYW5jaFNsb3RDb3VudGVyID0gdGhpcy5IRUFEKCkgPyAxIDogMDtcblxuICAvLyBUaGVuIGl0ZXJhdGUgZnJvbSB0aGUgYm90dG9tIHRvIGZpeCB0aGUgb3JkZXJzIG9mIHRoZSBicmFuY2hlc1xuICBmb3IgKHZhciBpID0gbm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmIChub2RlLmFuY2VzdG9yT2ZIRUFEVGltZVN0YW1wID09IHVwZGF0ZVRpbWVTdGFtcCkgY29udGludWU7XG4gICAgdmFyIGlkZW9sb2dpY2FsQnJhbmNoID0gbm9kZS5pZGVvbG9naWNhbEJyYW5jaCgpO1xuXG4gICAgLy8gRmlyc3Qgb2NjdXJlbmNlIG9mIHRoZSBicmFuY2gsIGZpbmQgYW4gZW1wdHkgc2xvdCBmb3IgdGhlIGJyYW5jaFxuICAgIGlmIChpZGVvbG9naWNhbEJyYW5jaC5sYXN0U2xvdHRlZFRpbWVTdGFtcCAhPSB1cGRhdGVUaW1lU3RhbXApIHtcbiAgICAgIGlkZW9sb2dpY2FsQnJhbmNoLmxhc3RTbG90dGVkVGltZVN0YW1wID0gdXBkYXRlVGltZVN0YW1wO1xuICAgICAgaWRlb2xvZ2ljYWxCcmFuY2guYnJhbmNoT3JkZXIgPSBicmFuY2hTbG90Q291bnRlcisrXG4gICAgfVxuXG4gICAgbm9kZS5icmFuY2hPcmRlcihpZGVvbG9naWNhbEJyYW5jaC5icmFuY2hPcmRlcik7XG4gIH1cblxuICBzZWxmLmhlaWdoc3RCcmFuY2hPcmRlciA9IGJyYW5jaFNsb3RDb3VudGVyIC0gMTtcbiAgdmFyIHByZXZOb2RlO1xuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLmFuY2VzdG9yT2ZIRUFEKG5vZGUuYW5jZXN0b3JPZkhFQURUaW1lU3RhbXAgPT0gdXBkYXRlVGltZVN0YW1wKTtcbiAgICBpZiAobm9kZS5hbmNlc3Rvck9mSEVBRCgpKSBub2RlLmJyYW5jaE9yZGVyKDApO1xuICAgIG5vZGUuYWJvdmVOb2RlID0gcHJldk5vZGU7XG4gICAgaWYgKHByZXZOb2RlKSBwcmV2Tm9kZS5iZWxvd05vZGUgPSBub2RlO1xuICAgIHByZXZOb2RlID0gbm9kZTtcbiAgfSk7XG5cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0RWRnZSA9IGZ1bmN0aW9uKG5vZGVBc2hhMSwgbm9kZUJzaGExKSB7XG4gIHZhciBpZCA9IG5vZGVBc2hhMSArICctJyArIG5vZGVCc2hhMTtcbiAgdmFyIGVkZ2UgPSB0aGlzLmVkZ2VzQnlJZFtpZF07XG4gIGlmICghZWRnZSkge1xuICAgIGVkZ2UgPSB0aGlzLmVkZ2VzQnlJZFtpZF0gPSBuZXcgRWRnZVZpZXdNb2RlbCh0aGlzLCBub2RlQXNoYTEsIG5vZGVCc2hhMSk7XG4gIH1cbiAgcmV0dXJuIGVkZ2U7XG59XG5cbkdyYXBoVmlld01vZGVsLl9tYXJrSWRlb2xvZ2ljYWxTdGFtcCA9IDA7XG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUubWFya05vZGVzSWRlb2xvZ2ljYWxCcmFuY2hlcyA9IGZ1bmN0aW9uKHJlZnMsIG5vZGVzLCBub2Rlc0J5SWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZWZzID0gcmVmcy5maWx0ZXIoZnVuY3Rpb24ocikgeyByZXR1cm4gISFyLm5vZGUoKTsgfSk7XG4gIHJlZnMgPSByZWZzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIGlmIChhLmlzTG9jYWwgJiYgIWIuaXNMb2NhbCkgcmV0dXJuIC0xO1xuICAgIGlmIChiLmlzTG9jYWwgJiYgIWEuaXNMb2NhbCkgcmV0dXJuIDE7XG4gICAgaWYgKGEuaXNCcmFuY2ggJiYgIWIuaXNCcmFuY2gpIHJldHVybiAtMTtcbiAgICBpZiAoYi5pc0JyYW5jaCAmJiAhYS5pc0JyYW5jaCkgcmV0dXJuIDE7XG4gICAgaWYgKGEuaXNIRUFEICYmICFiLmlzSEVBRCkgcmV0dXJuIDE7XG4gICAgaWYgKCFhLmlzSEVBRCAmJiBiLmlzSEVBRCkgcmV0dXJuIC0xO1xuICAgIGlmIChhLmlzU3Rhc2ggJiYgIWIuaXNTdGFzaCkgcmV0dXJuIDE7XG4gICAgaWYgKGIuaXNTdGFzaCAmJiAhYS5pc1N0YXNoKSByZXR1cm4gLTE7XG4gICAgaWYgKGEubm9kZSgpICYmIGEubm9kZSgpLmRhdGUgJiYgYi5ub2RlKCkgJiYgYi5ub2RlKCkuZGF0ZSlcbiAgICAgIHJldHVybiBhLm5vZGUoKS5kYXRlIC0gYi5ub2RlKCkuZGF0ZTtcbiAgICByZXR1cm4gYS5yZWZOYW1lIDwgYi5yZWZOYW1lID8gLTEgOiAxO1xuICB9KTtcbiAgdmFyIHN0YW1wID0gR3JhcGhWaWV3TW9kZWwuX21hcmtJZGVvbG9naWNhbFN0YW1wKys7XG4gIHJlZnMuZm9yRWFjaChmdW5jdGlvbihyZWYpIHtcbiAgICBzZWxmLnRyYXZlcnNlTm9kZVBhcmVudHMocmVmLm5vZGUoKSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUuc3RhbXAgPT0gc3RhbXApIHJldHVybiBmYWxzZTtcbiAgICAgIG5vZGUuc3RhbXAgPSBzdGFtcDtcbiAgICAgIG5vZGUuaWRlb2xvZ2ljYWxCcmFuY2gocmVmKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9KTtcbn1cblxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLnRyYXZlcnNlTm9kZVBhcmVudHMgPSBmdW5jdGlvbihub2RlLCBjYWxsYmFjaykge1xuICBpZiAoIWNhbGxiYWNrKG5vZGUpKSByZXR1cm4gZmFsc2U7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5wYXJlbnRzKCkubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBpZiBwYXJlbnQsIHRyYXZlcnMgcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHRoaXMubm9kZXNCeUlkW25vZGUucGFyZW50cygpW2ldXTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICB0aGlzLnRyYXZlcnNlTm9kZVBhcmVudHMocGFyZW50LCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG59XG5cbkdyYXBoVmlld01vZGVsLnByb3RvdHlwZS5oYW5kbGVCdWJibGVkQ2xpY2sgPSBmdW5jdGlvbihlbGVtLCBldmVudCkge1xuICAvLyBJZiB0aGUgY2xpY2tlZCBlbGVtZW50IGlzIGJvdW5kIHRvIHRoZSBjdXJyZW50IGFjdGlvbiBjb250ZXh0LFxuICAvLyB0aGVuIGxldCdzIG5vdCBkZXNlbGVjdCBpdC5cbiAgaWYgKGtvLmRhdGFGb3IoZXZlbnQudGFyZ2V0KSA9PT0gdGhpcy5jdXJyZW50QWN0aW9uQ29udGV4dCgpKSByZXR1cm47XG4gIGlmICh0aGlzLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgJiYgdGhpcy5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgR2l0Tm9kZVZpZXdNb2RlbCkge1xuICAgIHRoaXMuY3VycmVudEFjdGlvbkNvbnRleHQoKS50b2dnbGVTZWxlY3RlZCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY3VycmVudEFjdGlvbkNvbnRleHQobnVsbCk7XG4gIH1cbiAgLy8gSWYgdGhlIGNsaWNrIHdhcyBvbiBhbiBpbnB1dCBlbGVtZW50LCB0aGVuIGxldCdzIGFsbG93IHRoZSBkZWZhdWx0IGFjdGlvbiB0byBwcm9jZWVkLlxuICAvLyBUaGlzIGlzIGVzcGVjaWFsbHkgbmVlZGVkIHNpbmNlIGZvciBzb21lIHN0cmFuZ2UgcmVhc29uIGFueSBzdWJtaXQgKGllLiBlbnRlciBpbiBhIHRleHRib3gpXG4gIC8vIHdpbGwgdHJpZ2dlciBhIGNsaWNrIGV2ZW50IG9uIHRoZSBzdWJtaXQgaW5wdXQgb2YgdGhlIGZvcm0sIHdoaWNoIHdpbGwgZW5kIHVwIGhlcmUsXG4gIC8vIGFuZCBpZiB3ZSBkb24ndCByZXR1cm4gdHJ1ZSwgdGhlbiB0aGUgc3VibWl0IGV2ZW50IGlzIG5ldmVyIGZpcmVkLCBicmVha2luZyBzdHVmZi5cbiAgaWYgKGV2ZW50LnRhcmdldC5ub2RlTmFtZSA9PT0gJ0lOUFVUJykgcmV0dXJuIHRydWU7XG59XG5cbkdyYXBoVmlld01vZGVsLnByb3RvdHlwZS5vblByb2dyYW1FdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGlmIChldmVudC5ldmVudCA9PSAnZ2l0LWRpcmVjdG9yeS1jaGFuZ2VkJykge1xuICAgIHRoaXMubG9hZE5vZGVzRnJvbUFwaVRocm90dGxlZCgpO1xuICAgIHRoaXMudXBkYXRlQnJhbmNoZXNUaHJvdHRsZWQoKTtcbiAgfSBlbHNlIGlmIChldmVudC5ldmVudCA9PSAncmVxdWVzdC1hcHAtY29udGVudC1yZWZyZXNoJykge1xuICAgIHRoaXMubG9hZE5vZGVzRnJvbUFwaVRocm90dGxlZCgpO1xuICB9IGVsc2UgaWYgKGV2ZW50LmV2ZW50ID09ICdyZW1vdGUtdGFncy11cGRhdGUnKSB7XG4gICAgdGhpcy5zZXRSZW1vdGVUYWdzKGV2ZW50LnRhZ3MpO1xuICB9IGVsc2UgaWYgKGV2ZW50LmV2ZW50ID09ICdjdXJyZW50LXJlbW90ZS1jaGFuZ2VkJykge1xuICAgIHRoaXMuY3VycmVudFJlbW90ZShldmVudC5uZXdSZW1vdGUpO1xuICB9IGVsc2UgaWYgKGV2ZW50LmV2ZW50ID09ICdncmFwaC1yZW5kZXInKSB7XG4gICAgdGhpcy5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZS5yZW5kZXIoKTtcbiAgICB9KTtcbiAgfVxufVxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLnVwZGF0ZUJyYW5jaGVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnNlcnZlci5nZXRQcm9taXNlKCcvY2hlY2tvdXQnLCB7IHBhdGg6IHRoaXMucmVwb1BhdGgoKSB9KVxuICAgIC50aGVuKGZ1bmN0aW9uKHJlcykgeyBzZWxmLmNoZWNrZWRPdXRCcmFuY2gocmVzKTsgfSlcbiAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyLmVycm9yQ29kZSAhPSAnbm90LWEtcmVwb3NpdG9yeScpIHRocm93IGVycjtcbiAgICB9KVxufVxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLnNldFJlbW90ZVRhZ3MgPSBmdW5jdGlvbihyZW1vdGVUYWdzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG5vZGVJZHNUb1JlbW90ZVRhZ3MgPSB7fTtcbiAgcmVtb3RlVGFncy5mb3JFYWNoKGZ1bmN0aW9uKHJlZikge1xuICAgIGlmIChyZWYubmFtZS5pbmRleE9mKCdee30nKSAhPSAtMSkge1xuICAgICAgdmFyIHRhZ1JlZiA9IHJlZi5uYW1lLnNsaWNlKDAsIHJlZi5uYW1lLmxlbmd0aCAtICdee30nLmxlbmd0aCk7XG4gICAgICB2YXIgbmFtZSA9ICdyZW1vdGUtdGFnOiAnICsgcmVmLnJlbW90ZSArICcvJyArIHRhZ1JlZi5zcGxpdCgnLycpWzJdO1xuICAgICAgc2VsZi5nZXRSZWYobmFtZSkubm9kZShzZWxmLmdldE5vZGUocmVmLnNoYTEpKTtcbiAgICB9XG4gIH0pO1xufVxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLmNoZWNrSGVhZE1vdmUgPSBmdW5jdGlvbih0b05vZGUpIHtcbiAgaWYgKHRoaXMuSEVBRCgpID09PSB0b05vZGUpIHtcbiAgICB0aGlzLkhFQURyZWYubm9kZSh0b05vZGUpO1xuICB9XG59XG4iLCJ2YXIgZ2V0RWRnZU1vZGVsV2l0aEQgPSBmdW5jdGlvbihkLCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VEYXNoYXJyYXksIG1hcmtlckVuZCkge1xuICByZXR1cm4geyBkOiBkLFxuICAgICAgICAgIHN0cm9rZTogc3Ryb2tlID8gc3Ryb2tlIDogJyM0QTRBNEEnLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCA/IHN0cm9rZVdpZHRoIDogJzgnLFxuICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5ID8gc3Ryb2tlRGFzaGFycmF5IDogJzEwLCA1JyxcbiAgICAgICAgICBtYXJrZXJFbmQ6IG1hcmtlckVuZCA/IG1hcmtlckVuZCA6ICcnIH07XG59XG5cbnZhciBnZXRFZGdlTW9kZWwgPSBmdW5jdGlvbihzY3gsIHNjeSwgdGN4LCB0Y3ksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZURhc2hhcnJheSwgbWFya2VyRW5kKSB7XG4gIHJldHVybiBnZXRFZGdlTW9kZWxXaXRoRChcIk0gXCIgKyBzY3ggKyBcIiBcIiArIHNjeSArIFwiIEwgXCIgKyB0Y3ggKyBcIiBcIiArIHRjeSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlRGFzaGFycmF5LCBtYXJrZXJFbmQpO1xufVxuXG52YXIgZ2V0Tm9kZU1vZGVsID0gZnVuY3Rpb24oY3gsIGN5LCByLCBmaWxsLCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VEYXNoYXJyYXkpIHtcbiAgcmV0dXJuIHsgY3g6IGN4LFxuICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICByOiByLFxuICAgICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgICAgc3Ryb2tlOiBzdHJva2UgPyBzdHJva2UgOiAnIzQxREUzQycsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoID8gc3Ryb2tlV2lkdGggOiAnOCcsXG4gICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXkgPyBzdHJva2VEYXNoYXJyYXkgOiAnMTAsIDUnIH07XG59XG5cbmZ1bmN0aW9uIEhvdmVyVmlld01vZGVsKCkge1xuICB0aGlzLmJnRWRnZXMgPSBbXTtcbiAgdGhpcy5ub2RlcyA9IFtdO1xuICB0aGlzLmZnRWRnZXMgPSBbXTtcbn1cblxuZnVuY3Rpb24gTWVyZ2VWaWV3TW9kZWwoZ3JhcGgsIGhlYWROb2RlLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgSG92ZXJWaWV3TW9kZWwuY2FsbCh0aGlzKTtcbiAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICB0aGlzLmJnRWRnZXMgPSBbIGdldEVkZ2VNb2RlbChoZWFkTm9kZS5jeCgpLCAoaGVhZE5vZGUuY3koKSAtIDExMCksIGhlYWROb2RlLmN4KCksIGhlYWROb2RlLmN5KCkpLFxuICAgICAgICAgICAgICAgIGdldEVkZ2VNb2RlbChoZWFkTm9kZS5jeCgpLCAoaGVhZE5vZGUuY3koKSAtIDExMCksIG5vZGUuY3goKSwgbm9kZS5jeSgpKSBdO1xuICB0aGlzLm5vZGVzID0gWyBnZXROb2RlTW9kZWwoaGVhZE5vZGUuY3goKSwgaGVhZE5vZGUuY3koKSAtIDExMCwgTWF0aC5tYXgoaGVhZE5vZGUucigpLCBub2RlLnIoKSksICcjMjUyODMzJywgJyM0MURFM0MnLCAnOCcsICcxMCwgNScpIF07XG5cbiAgZ3JhcGguZGltQ29tbWl0KHRydWUpO1xufVxuZXhwb3J0cy5NZXJnZVZpZXdNb2RlbCA9IE1lcmdlVmlld01vZGVsO1xuTWVyZ2VWaWV3TW9kZWwucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ncmFwaC5kaW1Db21taXQoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBSZWJhc2VWaWV3TW9kZWwob250bywgbm9kZXNUaGF0V2lsbE1vdmUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBIb3ZlclZpZXdNb2RlbC5jYWxsKHRoaXMpO1xuICBub2Rlc1RoYXRXaWxsTW92ZSA9IG5vZGVzVGhhdFdpbGxNb3ZlLnNsaWNlKDAsIC0xKTtcblxuICBpZiAobm9kZXNUaGF0V2lsbE1vdmUubGVuZ3RoID09IDApIHJldHVybjtcblxuICB0aGlzLmJnRWRnZXMucHVzaChnZXRFZGdlTW9kZWwob250by5jeCgpLCBvbnRvLmN5KCksIG9udG8uY3goKSwgb250by5jeSgpIC0gNjApKTtcbiAgbm9kZXNUaGF0V2lsbE1vdmUuZm9yRWFjaChmdW5jdGlvbihub2RlLCBpKSB7XG4gICAgdmFyIGN5ID0gb250by5jeSgpICsgKC05MCAqIChpICsgMSkpO1xuICAgIHNlbGYubm9kZXMucHVzaChnZXROb2RlTW9kZWwob250by5jeCgpLCBjeSwgMjgsICd0cmFuc3BhcmVudCcpKTtcbiAgICBpZiAoaSArIDEgPCBub2Rlc1RoYXRXaWxsTW92ZS5sZW5ndGgpIHtcbiAgICAgIHNlbGYuYmdFZGdlcy5wdXNoKGdldEVkZ2VNb2RlbChvbnRvLmN4KCksIChjeSAtIDI1KSwgb250by5jeCgpLCAoY3kgLSA2NSkpKTtcbiAgICB9XG4gIH0pO1xufVxuZXhwb3J0cy5SZWJhc2VWaWV3TW9kZWwgPSBSZWJhc2VWaWV3TW9kZWw7XG5cbmZ1bmN0aW9uIFJlc2V0Vmlld01vZGVsKG5vZGVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgSG92ZXJWaWV3TW9kZWwuY2FsbCh0aGlzKTtcblxuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBzZWxmLmZnRWRnZXMucHVzaChnZXRFZGdlTW9kZWxXaXRoRChub2RlLmdldExlZnRUb1JpZ2h0U3RyaWtlKCksICdyZ2IoMjU1LCAxMjksIDMxKScsICc4JywgJzAsIDAnKSlcbiAgICBzZWxmLmZnRWRnZXMucHVzaChnZXRFZGdlTW9kZWxXaXRoRChub2RlLmdldFJpZ2h0VG9MZWZ0U3RyaWtlKCksICdyZ2IoMjU1LCAxMjksIDMxKScsICc4JywgJzAsIDAnKSk7XG4gIH0pO1xufVxuZXhwb3J0cy5SZXNldFZpZXdNb2RlbCA9IFJlc2V0Vmlld01vZGVsO1xuXG5mdW5jdGlvbiBQdXNoVmlld01vZGVsKGZyb21Ob2RlLCB0b05vZGUpIHtcbiAgSG92ZXJWaWV3TW9kZWwuY2FsbCh0aGlzKTtcbiAgdGhpcy5mZ0VkZ2VzID0gW2dldEVkZ2VNb2RlbChmcm9tTm9kZS5jeCgpLCBmcm9tTm9kZS5jeSgpLCB0b05vZGUuY3goKSwgKHRvTm9kZS5jeSgpICsgNDApLCAncmdiKDYxLCAxMzksIDI1NSknLCAnMTUnLCAnMTAsIDUnLCAndXJsKCNwdXNoQXJyb3dFbmQpJyApXTtcbn1cbmV4cG9ydHMuUHVzaFZpZXdNb2RlbCA9IFB1c2hWaWV3TW9kZWw7XG5cbmZ1bmN0aW9uIFNxdWFzaFZpZXdNb2RlbChmcm9tLCBvbnRvKSB7XG4gIEhvdmVyVmlld01vZGVsLmNhbGwodGhpcyk7XG5cbiAgbGV0IHBhdGggPSBmcm9tLmdldFBhdGhUb0NvbW1vbkFuY2VzdG9yKG9udG8pO1xuXG4gIGlmIChwYXRoLmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHBhdGgubGVuZ3RoID09IDEpIHtcbiAgICBwYXRoID0gb250by5nZXRQYXRoVG9Db21tb25BbmNlc3Rvcihmcm9tKVxuICB9IGVsc2Uge1xuICAgIHRoaXMubm9kZXMucHVzaChnZXROb2RlTW9kZWwob250by5jeCgpLCBvbnRvLmN5KCkgLSAxMjAsIDI4LCAndHJhbnNwYXJlbnQnKSk7XG4gIH1cblxuICBwYXRoLnNsaWNlKDAsIC0xKS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgdGhpcy5ub2Rlcy5wdXNoKGdldE5vZGVNb2RlbChub2RlLmN4KCksIG5vZGUuY3koKSwgbm9kZS5yKCkgKyAyLCAncmdiYSgxMDAsIDYwLCAyMjIsIDAuOCknKSk7XG4gIH0pO1xufVxuZXhwb3J0cy5TcXVhc2hWaWV3TW9kZWwgPSBTcXVhc2hWaWV3TW9kZWw7XG4iLCJ2YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuXG52YXIgU2VsZWN0YWJsZSA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gIHRoaXMuc2VsZWN0ZWQgPSBrby5jb21wdXRlZCh7XG4gICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSA9PSB0aGlzO1xuICAgIH0sXG4gICAgd3JpdGU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgLy8gdmFsIGlzIHRoaXMgaWYgd2UncmUgY2FsbGVkIGZyb20gYSBjbGljayBrbyBiaW5kaW5nXG4gICAgICBpZiAodmFsID09PSB0aGlzIHx8IHZhbCA9PT0gdHJ1ZSkge1xuICAgICAgICBncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSA9PSB0aGlzKSB7XG4gICAgICAgIGdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KG51bGwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb3duZXI6IHRoaXNcbiAgfSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RhYmxlO1xuIl19
