(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

var ko = require('knockout');
var moment = require('moment');
var components = require('ungit-components');

components.register('stash', function(args) {
  return new StashViewModel(args.server, args.repoPath);
});

function StashItemViewModel(stash, data) {
  this.stash = stash;
  this.server = stash.server;
  this.id = data.reflogId;
  this.sha1 = data.sha1;
  this.title = data.reflogName + ' ' + moment(new Date(data.commitDate)).fromNow();
  this.message = data.message;
  this.stashPopProgressBar = components.create('progressBar', { predictionMemoryKey: 'stash-pop', temporary: true });
  this.showCommitDiff = ko.observable(false);

  this.commitDiff = ko.observable(components.create('commitDiff', {
    fileLineDiffs: data.fileLineDiffs.slice(),
    sha1: this.sha1,
    repoPath: stash.repoPath,
    server: stash.server
  }));
}
StashItemViewModel.prototype.apply = function() {
  var self = this;
  this.stashPopProgressBar.start();
  this.server.delPromise('/stashes/' + this.id, { path: this.stash.repoPath(), apply: true }).finally(function() {
    self.stashPopProgressBar.stop();
  });
}
StashItemViewModel.prototype.drop = function() {
  var self = this;
  components.create('yesnodialog', { title: 'Are you sure you want to drop the stash?', details: 'This operation cannot be undone.'})
    .show()
    .closeThen(function(diag) {
      if (diag.result()) {
          self.stashPopProgressBar.start();
          self.server.delPromise('/stashes/' + self.id, { path: self.stash.repoPath() }).finally(function() {
              self.stashPopProgressBar.stop();
          });
      }
  });
}
StashItemViewModel.prototype.toggleShowCommitDiffs = function() {
  this.showCommitDiff(!this.showCommitDiff());
}

function StashViewModel(server, repoPath) {
  var self = this;
  this.server = server;
  this.repoPath = repoPath;
  this.stashedChanges = ko.observable([]);
  this.isShow = ko.observable(localStorage['showStash'] === 'true');
  this.visible = ko.computed(function() { return self.stashedChanges().length > 0 && self.isShow(); });
  this.refresh();
}

StashViewModel.prototype.updateNode = function(parentElement) {
  if (!this.isDisabled) ko.renderTemplate('stash', this, {}, parentElement);
}
StashViewModel.prototype.onProgramEvent = function(event) {
  if (event.event == 'request-app-content-refresh' ||
    event.event == 'working-tree-changed' ||
    event.event == 'git-directory-changed')
    this.refresh();
}
StashViewModel.prototype.refresh = function() {
  var self = this;
  this.server.getPromise('/stashes', { path: this.repoPath() })
    .then(function(stashes) {
      var changed = self.stashedChanges().length != stashes.length;
      if (!changed) {
        changed = !self.stashedChanges().every(function(item1) {
          return stashes.some(function(item2) {
            return item1.sha1 == item2.sha1;
          });
        });
      }

      if (changed) {
        self.stashedChanges(stashes.map(function(item) { return new StashItemViewModel(self, item); }));
      }
    }).catch(function(err) {
      if (err.errorCode != 'no-such-path') throw err
    })
}
StashViewModel.prototype.toggleShowStash = function() {
  this.isShow(!this.isShow());
  localStorage['showStash'] = this.isShow();
}

},{"knockout":"knockout","moment":"moment","ungit-components":"ungit-components"}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL3N0YXNoL3N0YXNoLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xudmFyIGNvbXBvbmVudHMgPSByZXF1aXJlKCd1bmdpdC1jb21wb25lbnRzJyk7XG5cbmNvbXBvbmVudHMucmVnaXN0ZXIoJ3N0YXNoJywgZnVuY3Rpb24oYXJncykge1xuICByZXR1cm4gbmV3IFN0YXNoVmlld01vZGVsKGFyZ3Muc2VydmVyLCBhcmdzLnJlcG9QYXRoKTtcbn0pO1xuXG5mdW5jdGlvbiBTdGFzaEl0ZW1WaWV3TW9kZWwoc3Rhc2gsIGRhdGEpIHtcbiAgdGhpcy5zdGFzaCA9IHN0YXNoO1xuICB0aGlzLnNlcnZlciA9IHN0YXNoLnNlcnZlcjtcbiAgdGhpcy5pZCA9IGRhdGEucmVmbG9nSWQ7XG4gIHRoaXMuc2hhMSA9IGRhdGEuc2hhMTtcbiAgdGhpcy50aXRsZSA9IGRhdGEucmVmbG9nTmFtZSArICcgJyArIG1vbWVudChuZXcgRGF0ZShkYXRhLmNvbW1pdERhdGUpKS5mcm9tTm93KCk7XG4gIHRoaXMubWVzc2FnZSA9IGRhdGEubWVzc2FnZTtcbiAgdGhpcy5zdGFzaFBvcFByb2dyZXNzQmFyID0gY29tcG9uZW50cy5jcmVhdGUoJ3Byb2dyZXNzQmFyJywgeyBwcmVkaWN0aW9uTWVtb3J5S2V5OiAnc3Rhc2gtcG9wJywgdGVtcG9yYXJ5OiB0cnVlIH0pO1xuICB0aGlzLnNob3dDb21taXREaWZmID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG5cbiAgdGhpcy5jb21taXREaWZmID0ga28ub2JzZXJ2YWJsZShjb21wb25lbnRzLmNyZWF0ZSgnY29tbWl0RGlmZicsIHtcbiAgICBmaWxlTGluZURpZmZzOiBkYXRhLmZpbGVMaW5lRGlmZnMuc2xpY2UoKSxcbiAgICBzaGExOiB0aGlzLnNoYTEsXG4gICAgcmVwb1BhdGg6IHN0YXNoLnJlcG9QYXRoLFxuICAgIHNlcnZlcjogc3Rhc2guc2VydmVyXG4gIH0pKTtcbn1cblN0YXNoSXRlbVZpZXdNb2RlbC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnN0YXNoUG9wUHJvZ3Jlc3NCYXIuc3RhcnQoKTtcbiAgdGhpcy5zZXJ2ZXIuZGVsUHJvbWlzZSgnL3N0YXNoZXMvJyArIHRoaXMuaWQsIHsgcGF0aDogdGhpcy5zdGFzaC5yZXBvUGF0aCgpLCBhcHBseTogdHJ1ZSB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuc3Rhc2hQb3BQcm9ncmVzc0Jhci5zdG9wKCk7XG4gIH0pO1xufVxuU3Rhc2hJdGVtVmlld01vZGVsLnByb3RvdHlwZS5kcm9wID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgY29tcG9uZW50cy5jcmVhdGUoJ3llc25vZGlhbG9nJywgeyB0aXRsZTogJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkcm9wIHRoZSBzdGFzaD8nLCBkZXRhaWxzOiAnVGhpcyBvcGVyYXRpb24gY2Fubm90IGJlIHVuZG9uZS4nfSlcbiAgICAuc2hvdygpXG4gICAgLmNsb3NlVGhlbihmdW5jdGlvbihkaWFnKSB7XG4gICAgICBpZiAoZGlhZy5yZXN1bHQoKSkge1xuICAgICAgICAgIHNlbGYuc3Rhc2hQb3BQcm9ncmVzc0Jhci5zdGFydCgpO1xuICAgICAgICAgIHNlbGYuc2VydmVyLmRlbFByb21pc2UoJy9zdGFzaGVzLycgKyBzZWxmLmlkLCB7IHBhdGg6IHNlbGYuc3Rhc2gucmVwb1BhdGgoKSB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBzZWxmLnN0YXNoUG9wUHJvZ3Jlc3NCYXIuc3RvcCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICB9KTtcbn1cblN0YXNoSXRlbVZpZXdNb2RlbC5wcm90b3R5cGUudG9nZ2xlU2hvd0NvbW1pdERpZmZzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2hvd0NvbW1pdERpZmYoIXRoaXMuc2hvd0NvbW1pdERpZmYoKSk7XG59XG5cbmZ1bmN0aW9uIFN0YXNoVmlld01vZGVsKHNlcnZlciwgcmVwb1BhdGgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgdGhpcy5yZXBvUGF0aCA9IHJlcG9QYXRoO1xuICB0aGlzLnN0YXNoZWRDaGFuZ2VzID0ga28ub2JzZXJ2YWJsZShbXSk7XG4gIHRoaXMuaXNTaG93ID0ga28ub2JzZXJ2YWJsZShsb2NhbFN0b3JhZ2VbJ3Nob3dTdGFzaCddID09PSAndHJ1ZScpO1xuICB0aGlzLnZpc2libGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYuc3Rhc2hlZENoYW5nZXMoKS5sZW5ndGggPiAwICYmIHNlbGYuaXNTaG93KCk7IH0pO1xuICB0aGlzLnJlZnJlc2goKTtcbn1cblxuU3Rhc2hWaWV3TW9kZWwucHJvdG90eXBlLnVwZGF0ZU5vZGUgPSBmdW5jdGlvbihwYXJlbnRFbGVtZW50KSB7XG4gIGlmICghdGhpcy5pc0Rpc2FibGVkKSBrby5yZW5kZXJUZW1wbGF0ZSgnc3Rhc2gnLCB0aGlzLCB7fSwgcGFyZW50RWxlbWVudCk7XG59XG5TdGFzaFZpZXdNb2RlbC5wcm90b3R5cGUub25Qcm9ncmFtRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICBpZiAoZXZlbnQuZXZlbnQgPT0gJ3JlcXVlc3QtYXBwLWNvbnRlbnQtcmVmcmVzaCcgfHxcbiAgICBldmVudC5ldmVudCA9PSAnd29ya2luZy10cmVlLWNoYW5nZWQnIHx8XG4gICAgZXZlbnQuZXZlbnQgPT0gJ2dpdC1kaXJlY3RvcnktY2hhbmdlZCcpXG4gICAgdGhpcy5yZWZyZXNoKCk7XG59XG5TdGFzaFZpZXdNb2RlbC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VydmVyLmdldFByb21pc2UoJy9zdGFzaGVzJywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoKCkgfSlcbiAgICAudGhlbihmdW5jdGlvbihzdGFzaGVzKSB7XG4gICAgICB2YXIgY2hhbmdlZCA9IHNlbGYuc3Rhc2hlZENoYW5nZXMoKS5sZW5ndGggIT0gc3Rhc2hlcy5sZW5ndGg7XG4gICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAgICAgY2hhbmdlZCA9ICFzZWxmLnN0YXNoZWRDaGFuZ2VzKCkuZXZlcnkoZnVuY3Rpb24oaXRlbTEpIHtcbiAgICAgICAgICByZXR1cm4gc3Rhc2hlcy5zb21lKGZ1bmN0aW9uKGl0ZW0yKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTEuc2hhMSA9PSBpdGVtMi5zaGExO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgc2VsZi5zdGFzaGVkQ2hhbmdlcyhzdGFzaGVzLm1hcChmdW5jdGlvbihpdGVtKSB7IHJldHVybiBuZXcgU3Rhc2hJdGVtVmlld01vZGVsKHNlbGYsIGl0ZW0pOyB9KSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyLmVycm9yQ29kZSAhPSAnbm8tc3VjaC1wYXRoJykgdGhyb3cgZXJyXG4gICAgfSlcbn1cblN0YXNoVmlld01vZGVsLnByb3RvdHlwZS50b2dnbGVTaG93U3Rhc2ggPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pc1Nob3coIXRoaXMuaXNTaG93KCkpO1xuICBsb2NhbFN0b3JhZ2VbJ3Nob3dTdGFzaCddID0gdGhpcy5pc1Nob3coKTtcbn1cbiJdfQ==
